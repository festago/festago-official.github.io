{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"서론 안녕하세요. 페스타고의 글렌입니다. 🥃 페스타고에는 다양한 역할의 사용자가 존재합니다. 이렇게 다양한 역할의 사용자가 있다면 사용자의 역할에 맞는 인증과 인가 작업이 필요합니다. 단순히 역할에 따른 구분이라면 큰 문제가 없겠지만, 다양한 사용자들이 접속하는 환경에서 인증을 하는 방법에서 차이로 인해 문제가 발생했습니다. 어떠한 문제점에 직면했고, 이…","fields":{"slug":"/oauth2-multiple-user-auth/"},"frontmatter":{"date":"August 24, 2023","title":"페스타고의 인증 - 여러 사용자의 인증과 인가","tags":["OAuth2"]},"rawMarkdownBody":"\n## 서론\n\n안녕하세요.\n\n페스타고의 글렌입니다. 🥃\n\n페스타고에는 다양한 역할의 사용자가 존재합니다.\n\n이렇게 다양한 역할의 사용자가 있다면 사용자의 역할에 맞는 인증과 인가 작업이 필요합니다.\n\n단순히 역할에 따른 구분이라면 큰 문제가 없겠지만, 다양한 사용자들이 접속하는 환경에서 인증을 하는 방법에서 차이로 인해 문제가 발생했습니다.\n\n어떠한 문제점에 직면했고, 이것을 어떻게 해결했는지 설명하겠습니다.\n## 본론\n\n페스타고는 축제의 공연에 대한 티켓팅을 오프라인으로 기다리지 않고 온라인으로 편하게 예매하고 빠르게 출입을 가능하게 해주는 서비스입니다.\n\n잠깐 저희 서비스의 흐름에 관해 이야기를 해보겠습니다.\n\n사용자가 공연에 대해 티켓을 예매하려고 합니다.\n\n이때, 사용자가 티켓을 예매하려면 우선 공연과 축제가 생성되어 있어야 합니다.\n\n그렇다면 공연과 축제는 티켓을 예매하는 사용자가 생성을 하는 것일까요?\n\n공연과 축제를 생성하는 것은 티켓을 예매하는 사용자가 아닌, 축제와 공연을 개최하고 싶은 관리자입니다.\n\n그리고 예매한 티켓을 검사할 때도 마찬가지로, 티켓을 검사하는 사용자가 있습니다.\n\n티켓을 검사하는 사용자는 공연과 축제를 생성하는 관리자가 아닌, 관리자에 의해 고용된 스태프일 것입니다.\n\n이처럼 페스타고에는 역할별로 책임이 다른 사용자가 존재합니다.\n\n> 티켓을 예매하고 싶은 사용자 -> Member\n> \n> 축제와 공연을 계획하고 개최하고 싶은 사용자 -> Admin\n> \n> 티켓을 검사하고 싶은 사용자 -> Staff\n\n이렇듯 사용자들은 각자의 역할과 책임을 가지고 있습니다.\n\n그런데 어떻게 다양한 역할의 사용자를 구분할 수 있을까요?\n\n저희 서비스는 JWT 토큰을 기반으로 인증을 수행하니 JWT 토큰에 다음과 같은 값을 넣을 수 있을 것 같습니다.\n\n```json\n{\n    \"id\": 1,\n    \"role\": \"MEMBER\"\n}\n\n{\n    \"id\": 2,\n    \"role\": \"STAFF\"\n}\n\n{\n    \"id\": 3,\n    \"role\": \"ADMIN\"\n}\n```\n\n이렇게 토큰에 `role` 필드를 추가하면 사용자의 역할을 쉽게 구분할 수 있습니다.\n\n하지만 여기서 문제가 발생합니다.\n\n각 역할의 사용자들은 접속하는 환경이 다르다는 것입니다.\n\n일반 사용자와 스태프는 모바일 앱 환경에서 저희 서비스를 이용합니다.\n\n하지만 관리자는 모바일 앱을 사용하지 않고, 웹 페이지를 통해 저희 서비스를 이용합니다.\n\n관리자가 접속하는 환경에서는 전용 앱을 제작할 필요가 없고 간단한 웹 페이지만 있으면 되기 때문입니다.\n\n그런데 이것이 왜 문제가 되는 걸까요?\n\n모바일 앱 환경에서 요청을 보낼 때는 JWT 토큰을 HTTP 헤더에 담아 요청합니다.\n\n하지만 웹 페이지 환경에서는 JWT 토큰을 쿠키에 담아 요청합니다.\n\n이렇게 사용자의 환경마다 토큰을 보내는 방법이 다르니 문제가 발생합니다.\n\n여기서 이런 생각이 들 수 있습니다.\n\n> \"웹 페이지에서도 헤더에 토큰을 담아서 보내면 안되나요?\"\n\n웹 페이지를 통해 토큰을 헤더에 담아 요청을 하려면 다음과 같은 문제가 발생합니다.\n\n단순하게 토큰을 헤더에 담아 요청하는 과정은 다음과 같습니다.\n\n1. 로그인을 통해 token을 서버에서 얻는다.\n2. token을 어딘가에 저장한다.\n3. 요청마다 저장한 토큰을 헤더에 추가하여 서버에 전송한다.\n\n여기서 token을 어딘가에 저장해야 하는데, 저장할 장소는 `LocalStorage` 또는 `SessionStorage`를 사용합니다.\n\n그리고 다음과 같이 `Authorization` 헤더를 추가하여 요청을 보내면 됩니다.\n\n```js\nconst credentials = localStorage.getItem('credentials');\nfetch(\"/admin/function\", {  \n  method: \"POST\",  \n  headers: {  \n    \"Authorization\": `Bearer ${credentials}`,\n    \"Content-Type\": \"application/json\"  \n  },  \n  body: JSON.stringify(...)  \n})\n```\n\n코드만 본다면 저장된 토큰을 꺼내는 작업과 헤더에 토큰을 추가하는 작업 외에는 전혀 문제가 될 상황이라고 보이지는 않습니다.\n\n하지만 눈에 보이지 않는 보안 측면에 문제가 있습니다.\n\nLocalStorage 같은 저장소에 있는 값들은 XSS 공격에 취약하다는 것입니다.\n\n다음과 같은 자바스크립트 코드로 저희 서비스에서 제공된 토큰을 쉽게 탈취할 수 있습니다.\n\n```js\nlocalStorage.getItem('credentials');\n```\n\n하지만 쿠키 또한 자바스크립트 코드로 쉽게 XSS 공격이 가능합니다.\n\n다음과 같은 한 줄로 쿠키의 목록을 전부 출력할 수 있습니다.\n\n```js\ndocument.cookie;\n```\n\n하지만 쿠키의 경우 `HttpOnly`라는 플래그가 존재합니다.\n\n해당 플래그를 설정하면 자바스크립트로 접근할 수 없으므로, LocalStorage 보다 안전하게 토큰을 보관할 수 있습니다.\n\n또한 쿠키를 사용하면 매 요청 시 토큰을 꺼내고 헤더에 추가할 필요가 없으므로 개발의 편의성 또한 높습니다.\n\n따라서 이러한 상황으로 인해 헤더를 사용한 방법이 아닌, 쿠키를 사용한 방법을 선택했습니다.\n\n---\n### 기존의 인증 방식\n\n기존의 인증을 수행하는 방식은 다음과 같습니다.\n\n```java\n@Component\npublic class LoginMemberResolver implements HandlerMethodArgumentResolver {\n\n    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n\n    private final AuthExtractor authExtractor;\n\n    public LoginMemberResolver(AuthExtractor authExtractor) {\n        this.authExtractor = authExtractor;\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.getParameterType().equals(LoginMember.class) && parameter.hasParameterAnnotation(Login.class);\n    }\n\n    @Override\n    public LoginMember resolveArgument(...) {\n        String header = webRequest.getHeader(HttpHeaders.AUTHORIZATION);\n        String token = extractToken(header);\n        AuthPayload authPayload = authExtractor.extract(token);\n        return new LoginMember(authPayload.getMemberId());\n    }\n\n    private String extractToken(String header) {\n        validateHeader(header);\n        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n    }\n\n    private void validateHeader(String header) {\n        if (header == null) {\n            throw new UnauthorizedException(...);\n        }\n        if (!header.toLowerCase().startsWith(BEARER_TOKEN_PREFIX.toLowerCase())) {\n            throw new UnauthorizedException(...);\n        }\n    }\n}\n```\n\n이때는 역할이라는 도메인이 없고 단순히 사용자에 대한 인증만 있었기 때문에 `ArgumentResolver`로 인증 작업을 수행했습니다.\n\n따라서 다음과 같이 컨트롤러의 핸들러 메서드의 파라미터에 `@Login` 어노테이션을 붙이면 해당 핸들러에 인증 기능이 수행됩니다.\n\n```java\n@GetMapping(\"/profile\")\npublic ResponseEntity<MemberProfileResponse> findMemberProfile(@Login LoginMember loginMember) {\n    ...\n}\n```\n### 추가된 기능, 발생한 문제점\n\n지금까지 관리자 웹 페이지에 접속할 때 인증, 인가 작업 없이 누구나 접속이 가능했기 때문에 관리자에 대한 인증과 인가 기능을 추가해야 했습니다.\n\n위에서 설명했듯, 관리자에 대한 인증은 헤더가 아닌 쿠키를 사용합니다.\n\n하지만 기존의 인증 작업을 수행하는 `LoginMemberResolver`에는 헤더를 통한 인증만 되도록 구현되어 있습니다.\n\n```java\n@Component\npublic class LoginMemberResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override\n    public LoginMember resolveArgument(...) {\n        String header = webRequest.getHeader(HttpHeaders.AUTHORIZATION);\n        String token = extractToken(header);\n        AuthPayload authPayload = authExtractor.extract(token);\n        return new LoginMember(authPayload.getMemberId());\n    }\n    ...\n}\n```\n\n따라서 관리자의 인증은 기존의 `LoginMemberResolver`를 사용할 수 없고 새로운 `ArgumentResolver`가 필요합니다.\n\n```java\n@Component\npublic class LoginAdminResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override\n    public LoginMember resolveArgument(...) {\n        Cookie[] cookies = request.getCookies();\n        String token = extractToken(cookies);\n        AuthPayload authPayload = authExtractor.extract(token);\n        if (authPayload.getRole() != Role.ADMIN) {\n            throw new ForbiddenException(...);\n        }\n        return new LoginMember(authPayload.getId());\n    }\n}\n```\n\n그러면 이제 관리자 컨트롤러의 핸들러 메서드에는 다음과 같이 `@LoginAdmin` 어노테이션으로 관리자에 대한 인증과 인가를 수행할 수 있습니다.\n\n```java\n@PostMapping(\"/festivals\")\npublic ResponseEntity<Void> createFestival(@Admin LoginMember loginMember,\n                                           @RequestBody FestivalCreateRequest request) {\n    festivalService.create(request);  \n    return ResponseEntity.ok()\n        .build();\n}\n```\n\n이렇게 여러 사용자에 대한 인증과 인가 작업이 끝났을까요..?\n\n안타깝게도 여기에는 여러 문제점이 존재합니다.\n#### 필요하지 않은 파라미터\n\n`createFestival` 핸들러 메서드에서 `LoginMember` 파라미터를 사용하는 부분이 없습니다. 하지만 인증을 위해 핸들러 메서드의에 LoginMember 파라미터를 받아야 합니다.\n#### 정적 파일에 대한 인증\n\n인증 작업을 `ArgumentResolver`에서 수행하므로, 핸들러 메서드로 지정된 경로만 인증이 가능합니다.\n\n따라서 정적 파일에 대한 인증을 수행할 수 없습니다.\n\n따라서 관리자 웹 페이지의 JS 파일이 노출될 수 있습니다.\n\n> 어차피 JS 파일을 열어보더라도 인증이 되지 않으면 요청을 보낼 수 없긴 하나, 관리자의 엔드포인트가 노출된다는 점이 보안 측면에서 취약하다고 판단했습니다.\n### 어떻게 해결할 것인가?\n\n지금까지의 상황은 다음과 같습니다.\n\n![](images/20230822151035.png)\n![](images/20230822151040.png)\n![](images/20230822151045.png)\n\n따라서 문제점을 해결하려면, `ArgumentResolver`로 인증을 하는 것이 아닌 `Interceptor`로 특정 경로에 대한 인증을 수행하면 해결할 수 있습니다.\n\n> 여기서 `Interceptor`는  `HandlerInterceptor` 인터페이스를 구현한 클래스를 말합니다.\n\n`Interceptor`를 사용하면 요청과 응답을 공통으로 처리할 수 있습니다.\n\n또한 `HandlerInterceptor` 인터페이스에는 세 개의 default 메서드가 있습니다.\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n   return true;  \n}\n\ndefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { \n}\n\ndefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {  \n}\n```\n\n이 중에서 저희가 봐야할 메서드는 `preHandle()` 입니다.\n\n`preHandle()` 메서드는 요청이 들어올 때 실행되는 메서드로, 해당 메서드를 구현하여 요청이 핸들러 메서드로 넘어가기 전에 인증 과정을 처리할 수 있습니다.\n\n`HandlerInterceptor`를 구현한 Interceptor는 다음과 같이 `WebMvcConfigurer`를 구현한 클래스에 `addInterceptors()` 메서드를 재정의 한 뒤 `registry` 파라미터에 추가하면 됩니다.\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    ...\n    @Override  \n    public void addInterceptors(InterceptorRegistry registry) {  \n        registry.addInterceptor(adminAuthInterceptor())  \n            .addPathPatterns(\"/admin/**\", \"/js/admin/**\")  \n            .excludePathPatterns(\"/admin/login\");  \n        registry.addInterceptor(memberAuthInterceptor())\n            .addPathPatterns(\"/members/**\");\n    }\n\n    @Bean  \n    public HandlerInterceptor adminAuthInterceptor() {  \n        return new AuthInterceptor(Role.ADMIN, authExtractor);\n    }  \n      \n    @Bean  \n    public HandlerInterceptor memberAuthInterceptor() {  \n        return new AuthInterceptor(Role.MEMBER, authExtractor);\n    }\n}\n```\n#### Interceptor\n\n기존의 `ArgumentResolver`에서는 요청에서 토큰을 가져오는 것과 토큰을 `AuthExtractor`에 전달하여 `LoginMember`를 반환하는 두 가지의 책임이 있습니다.\n\n따라서 요청에서 토큰을 가져오는 책임을 Interceptor로 위임할 수 있을 것 같습니다.\n\n그런데 사용자와 관리자는 토큰을 보내는 방식이 달라서, 역할에 따라 토큰을 가져오는 메서드를 분리해야 합니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n\n    private final Role role;\n    private final AuthExtractor authExtractor;\n    \n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token;\n        if (role == Role.MEMBER) {\n            token = getHeaderToken(request);\n        }\n        if (role == Role.ADMIN) {\n            token = getCookieToken(request);\n        }\n        if (token == null) {\n            throw new UnauthorizedException(...);\n        }\n        AuthPayload authPayload = authExtractor.extract(token);\n        ...\n    }\n}\n```\n\n하지만 이 방법은 새로운 역할이 추가된다면 조건문이 추가로 생기게 될 것이고 한눈에 봐도 이 방법은 썩 유쾌하지 않아 보입니다.\n#### 서로 다른 인증 방식\n\n위의 구현에서는 요청에서 토큰을 가져오는 작업을 역할에 따라 구체적으로 처리하고 있습니다.\n\n역할에 따라 토큰을 가져오는 방식이 다른 것은 맞지만, 굳이 역할에 따라 토큰을 가져오는 방식을 분리할 필요가 있을까요?\n\n이것을 하나의 책임으로 본다면 다른 객체가 이것을 담당하게 하는 것을 생각해 볼 수 있습니다.\n\n```java\npublic interface TokenExtractor {\n    Optional<String> extract(HttpServletRequest request);\n}\n```\n\n그리고 `TokenExtractor`는 다음과 같이 두 개의 구현체로 구현됩니다.\n\n```java\npublic class CookieTokenExtractor implements TokenExtractor {\n    ...\n}\n\npublic class HeaderTokenExtractor implements TokenExtractor {\n    ...\n}\n```\n\n이제 요청에서 토큰을 가져오는 작업을 `TokenExtractor`에 위임할 수 있습니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n    ...\n    private final TokenExtractor tokenExtractor;\n\n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token = tokenExtractor.extract(request)\n            .orElseThrow(() -> new UnauthorizedException(...));\n        AuthPayload authPayload = authExtractor.extract(token);\n        if (authPayload.getRole() != role) {\n            throw new ForbiddenException(...);\n        }\n        return true; // boolean..?\n    }\n}\n```\n\n그런데 `preHandle()` 메서드의 반환 타입은 boolean인데, 어떻게 AuthPayload에 있는 값을 핸들러 메서드의 파라미터로 넘길 수 있을까요?\n#### HandlerInterceptor -> ArgumentResolver\n\n`preHandle()` 메서드로 넘어오는 `HttpServletRequest` 객체는 다음과 같은 메서드가 존재합니다.\n\n```java\nObject getAttribute(String name);\n\nvoid setAttribute(String name, Object o);\n```\n\n따라서 Interceptor에서 인증이 끝나고 반환된 `AuthPayload` 객체를 `setAttribute()` 메서드를 통해 `ArgumentResolver`로 전달할 수 있습니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n\n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token = tokenExtractor.extract(request)\n            .orElseThrow(() -> new UnauthorizedException(...));\n        AuthPayload authPayload = authExtractor.extract(token);\n        request.setAttribute(AuthPayload.class.getName(), authPayload);\n        return true;\n    }\n}\n```\n\n이제 `ArgumentResolver`는 WebRequest 객체의  `getAttribute()` 메서드를 통해 `AuthPayload`를 꺼낸 뒤, 핸들러 메서드의 파리미터에 값을 매핑하면 됩니다.\n\n> Attribute의 key가 겹칠 수 있으므로, `AuthPayload.class.getName()`과 같이 해당 클래스의 고유한 패키지 명과 클래스 명을 사용하여 해당 문제를 해결하였습니다.\n\n```java\npublic class AuthArgumentResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override  \n    public LogimMember resolveArgument(...) throws Exception {  \n        AuthPayload authPayload = getAuthPayload(webRequest);\n        return new LoginMember(authPayload.getId()); \n    }\n\n    private AuthPayload getAuthPayload(NativeWebRequest request) {\n        AuthPayload authPayload = (AuthPayload) request.getAttribute(AuthPayload.class.getName(), RequestAttributes.SCOPE_REQUEST);  \n        if (authPayload == null) {  \n            return AuthPayload.ANONYMOUS; // new AuthPayload(null, Role.ANONYMOUS); \n        }  \n        return authPayload;\n    }\n}\n```\n\n따라서 이제부터 사용자가 접속하는 경로에 따라 인증과 인가 기능이 수행됩니다.\n![](images/20230822170744.png)\n### 인증 인가 테스트\n\n그렇다면 이제 모든 기능을 제작했으니 테스트 코드를 작성해야겠죠?\n\n관리자 페이지를 접속할 때, 관리자 권한이 아닌 사용자면 401 상태코드가 반환되는 것을 검증하는 테스트 코드를 작성해 보겠습니다.\n\n```java\n@WebMvcTest(AdminController.class)\nclass AdminControllerTest {\n    @Test\n    void 토큰의_Role이_어드민이_아니면_401() throws Exception {  \n        // when & then  \n        mockMvc.perform(get(\"/admin\")  \n                .cookie(new Cookie(\"token\", \"token\")))  \n            .andExpect(status().isUnauthorized());  \n    }\n}\n```\n\n해당 테스트 코드는 당연하게 실패합니다.\n\n왜냐하면 `Interceptor` 필드의 `AuthExtractor`가 빈으로 등록되어 있지 않기 때문입니다.\n\n또한 `AuthExtractor`는 인터페이스이고, 해당 테스트에서는 JWT 토큰으로 인증을 할 필요가 없습니다.\n\n따라서 Mockito의 `@MockBean` 어노테이션을 사용하거나, 테스트 클래스에서 `@Import` 어노테이션을 사용하여 `AuthExtractor`를 빈으로 등록하면 됩니다.\n\n```java\n@Import(FakeAuthExtractor.class) // Fake\n@WebMvcTest(AdminController.class)\nclass AdminControllerTest {\n\n    @MockBean\n    AuthExtractor authExtractor; // Mock\n}\n```\n\n그런데 이렇게 Fake 객체를 사용하거나, Mock 객체를 사용할 때 다음과 같은 문제가 발생합니다.\n#### Fake 사용의 문제\n\n`FakeAuthExtractor` 클래스는 다음과 같이 구현됩니다.\n\n```java\npublic class FakeAuthExtractor implements AuthExtractor {\n    @Override  \n    public AuthPayload extract(String token) {  \n        if (Objects.equals(token, \"member\")) {\n            return new AuthPayload(1L, Role.MEMBER);\n        }\n        if (Objects.equals(token, \"admin\")) {\n            return new AuthPayload(1L, Role.ADMIN);  \n        }\n        return AuthPayload.ANONYMOUS;\n    }\n}\n```\n\nJWT 토큰을 직접 파싱하여, AuthPayload 객체를 가져올 필요는 없으니 단순히 하드코딩된 값으로 AuthPayload 객체를 반환합니다.\n\n하지만 해당 Fake 객체의 문제점은 테스트 코드가 `FakeAuthExtractor`의 구현 사항에 의존적으로 변하게 됩니다.\n\n```java\nmockMvc.perform(get(\"/admin\")  \n        .cookie(new Cookie(\"token\", \"member\"))) // 새로운 역할이 생기면 FakeAuthExtractor를 수정해야 한다!\n    .andExpect(status().isUnauthorized());  \n```\n#### Mock 사용의 문제\n\nMockito를 사용하면 Stub 객체를 매우 쉽게 만들 수 있습니다.\n\n하지만 Stub이 필요한 메서드마다  `given()`과 같이 모의 동작을 정의해 줘야 하는 중복 코드가 발생합니다.\n\n```java\n@Test\nvoid test1() {  \n    // given\n    given(authExtractor.extract(anyString()))    \n        .willReturn(new AuthPayload(1L, Role.MEMBER));\n    ...\n}\n\n@Test\nvoid test2() {  \n    // given\n    given(authExtractor.extract(anyString()))    \n        .willReturn(new AuthPayload(1L, Role.ADMIN));\n    ...\n}\n```\n\n#### 공통적인 문제점\n\n결국 Fake 객체를 사용하던, Mock 객체를 사용하는 방법이든 간에 테스트가 정상적으로 동작하려면 `AuthExtrator` 빈이 필요합니다.\n\n따라서 컨트롤러의 테스트 코드마다 해당 객체를 빈으로 등록하는 코드를 매번 작성해야 합니다.\n\n```java\n@Import(FakeAuthExtractor.class) \n\n// 또는\n\n@MockBean\nAuthExtractor authExtractor;\n```\n\n이러한 문제점은  `@WebMvcTest` 테스트에서, MVC 관련 빈들만 불러오기 때문에 발생합니다.\n\n```java\n@TypeExcludeFilters(WebMvcTypeExcludeFilter.class) <--\n...\npublic @interface WebMvcTest {\n    ...\n}\n```\n\n`WebMvcTypeExcludeFilter` 클래스를 보면 다음과 같이 특정 빈들만 등록하는 것을 볼 수 있습니다.\n\n```java\npublic final class WebMvcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<WebMvcTest> {\n    ...\n    static {  \n       Set<Class<?>> includes = new LinkedHashSet<>();  \n       includes.add(ControllerAdvice.class);  \n       includes.add(JsonComponent.class);  \n       includes.add(WebMvcConfigurer.class);  \n       includes.add(WebMvcRegistrations.class);  \n       includes.add(jakarta.servlet.Filter.class);  \n       includes.add(FilterRegistrationBean.class);  \n       includes.add(DelegatingFilterProxyRegistrationBean.class); \n       includes.add(HandlerMethodArgumentResolver.class);  \n       includes.add(HttpMessageConverter.class);  \n       includes.add(ErrorAttributes.class);  \n       includes.add(Converter.class);  \n       includes.add(GenericConverter.class);  \n       includes.add(HandlerInterceptor.class);\n       ...\n   }\n}\n```\n\n그렇다면 해결법은 생각보다 단순합니다.\n\n`@WebMvcTest` 어노테이션을 확장한 커스텀 `@WebMvcTest` 어노테이션을 만들면 됩니다.\n\n```java\n@WebMvcTest  \n@Import(TestAuthConfig.class)  \n@Retention(RetentionPolicy.RUNTIME)  \npublic @interface CustomWebMvcTest {  \n  \n    @AliasFor(\"controllers\")  \n    Class<?>[] value() default {};  \n  \n    @AliasFor(\"value\")  \n    Class<?>[] controllers() default {};  \n}\n```\n\n`@WebMvcTest`에는 속성으로 테스트할 컨트롤러의 클래스를 적어줘야 합니다.\n\n만약 적어주지 않으면 모든 컨트롤러를 빈으로 주입하니, `NoSuchBeanDefinitionException` 예외가 발생하므로 특정 컨트롤러 클래스를 적어주기 위해 기존 `@WebMvcTest` 어노테이션에 있던 파라미터들을 적어주었습니다.\n\n그리고 `@Import` 어노테이션으로 `TestAuthConfig` 클래스를 빈으로 주입하였습니다.\n\n`TestAuthConfig` 클래스는 다음과 같습니다.\n\n```java\n@TestConfiguration  \npublic class TestAuthConfig {\n\n    @Bean\n    public AuthExtractor authExtractor() {\n        // return Mockito.mock(AuthExtractor.class);\n        return new FakeAuthExtractor();\n    }\n}\n```\n\n이제 `@CustomWebMvcTest` 어노테이션을 사용하면 중복된 코드를 적지 않아도 됩니다!\n\n```java\n@CustomWebMvcTest(AdminController.class)\nclass AdminControllerTest {\n    @Test\n    void 토큰의_Role이_어드민이_아니면_401() throws Exception {  \n        // when & then  \n        mockMvc.perform(get(\"/admin\")  \n                .cookie(new Cookie(\"token\", \"token\")))  \n            .andExpect(status().isUnauthorized());  \n    }\n}\n```\n### 여전한 문제점\n\n하지만 중복된 코드를 지우긴 했어도 여전히 근본적인 문제는 남아있습니다.\n\nFake를 사용할 것이냐, Mock을 사용할 것이냐입니다.\n\nFake를 사용한다면 테스트 코드가 Fake의 동작에 종속적으로 되고, Mock을 사용한다면 매번 모의 동작을 정의해야 하는 문제가 발생합니다.\n\n해당 테스트의 핵심은 인증 기능을 수행하는 것이 아닌, 인증이 된 사용자만 요청을 수행할 수 있는지 검증하는 것입니다.\n\n따라서 인증의 구체적인 방법은 중요하지 않고, 경로에 따라 쿠키를 사용하는지, 헤더를 사용하는지와 인가된 사용자를 구분만 하면 됩니다.\n\n그렇다면 어떻게 이런 작업을 중복된 코드 없이 간단하게 구현할 수 있을까요?\n#### TestExecutionListener\n\n스프링은 다음과 같은 인터페이스를 제공합니다.\n\n```java\npublic interface TestExecutionListener {\n    default void beforeTestClass(TestContext testContext) throws Exception {};\n    default void prepareTestInstance(TestContext testContext) throws Exception {};\n    default void beforeTestMethod(TestContext testContext) throws Exception {};\n    default void afterTestMethod(TestContext testContext) throws Exception {};\n    default void afterTestClass(TestContext testContext) throws Exception {};\n}\n```\n\n해당 인터페이스는 테스트를 실행할 때, 전처리 과정을 수행할 메서드를 정의할 수 있습니다.\n\n따라서 해당 인터페이스를 구현한 클래스를 테스트 클래스에 등록시키면 중복된 코드를 없앨 수 있습니다.\n\n다음과 같이 커스텀 어노테이션을 만들어, 인증이 필요한 테스트 메서드마다 적용을 한다면 좋을 것 같습니다.\n\n```java\n@Retention(RetentionPolicy.RUNTIME)  \n@Target(ElementType.METHOD)  \npublic @interface WithMockAuth {  \n  \n    long id() default 1;  \n  \n    Role role() default Role.MEMBER;  \n}\n```\n\n```java\n@Test\nvoid 사용자가_로그인을_하지_않으면_아니면_401() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().isUnauthorized());  \n}\n\n@Test\n@WithMockAuth(role = Role.MEMBER)\nvoid 사용자가_어드민이_아니면_401() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().isUnauthorized());  \n}\n\n@Test\n@WithMockAuth(role = Role.ADMIN)\nvoid 사용자가_어드민_이면_200() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().ikOk());  \n}\n```\n\n하지만 어떻게 구현을 해야할까요?\n#### TestExecutionListener 구현\n\n잠깐 `AuthInterceptor`의 `preHandle()` 메서드를 보겠습니다.\n\n```java\n@Override  \npublic boolean preHandle(...) throws Exception {\n    String token = tokenExtractor.extract(request)\n        .orElseThrow(() -> new UnauthorizedException(...));\n    AuthPayload authPayload = authExtractor.extract(token);\n    if (authPayload.getRole() != role) {\n        throw new ForbiddenException(...);\n    }\n    request.setAttribute(AuthPayload.class.getName(), authPayload);\n    return true;\n}\n```\n\n인증, 인가에 대한 가장 큰 핵심적인 부분은 `AuthExtractor` 클래스의 `extract()` 메서드 입니다.\n\n그렇다면 `TestExecutionListener`를 사용해서 테스트가 수행되기 전 전처리 작업을 통해서 `extract()` 메서드의 반환 값을 조작하면 될 것 같습니다.\n\n`TestExecutionListener`의 추상 메서드의 파라미터에는 공통으로 `TestContext` 객체가 제공됩니다.\n\n`TestContext` 객체에는 다음과 같은 메서드를 사용할 수 있습니다.\n\n```java\npublic interface TestContext extends AttributeAccessor, Serializable {\n    ...\n    Method getTestMethod();\n    ...\n    ApplicationContext getApplicationContext();\n    ...\n}\n```\n\n`getTestMethod()` 메서드로 제공되는 `Method` 객체에는 메소드에 특정 어노테이션이 붙어있는지 확인하고, 해당 어노테이션을 가져오는 메서드가 제공됩니다.\n\n```java\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {  \n    return super.isAnnotationPresent(annotationClass);  \n}\n\npublic <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {  \n    return this.getAnnotation(annotationClass);  \n}\n```\n\n따라서 다음과 같이 테스트 메서드에 특정 어노테이션이 붙어있으면 다음과 같은 기능을 수행할 수 있습니다.\n\n1. 테스트 메서드에 특정 어노테이션이 붙어있는지 확인한다.\n2. 특정 어노테이션을 가져온다.\n3. ApplicationContext 객체를 가져온 뒤, AuthExtractor 빈을 꺼낸다.\n4. AuthExtractor가 특정 어노테이션의 속성으로 정의된 필드를 반환하도록 한다.\n\n테스트에 사용할 `AuthExtractor` 객체는 다음과 같이 구현하면 될 것 같습니다.\n\n```java\npublic class MockAuthExtractor implements AuthExtractor {  \n  \n    private Long memberId = null;  \n    private Role role = Role.ANONYMOUS;  \n  \n    public void setMemberId(Long memberId) {  \n        this.memberId = memberId;  \n    }  \n  \n    public void setRole(Role role) {  \n        this.role = role;  \n    }  \n  \n    @Override  \n    public AuthPayload extract(String token) {  \n        return new AuthPayload(memberId, role);  \n    }  \n}\n```\n\n그리고 `TestExecutionListener`를 구현한 클래스에서 `beforeTestMethod()` 메서드를 다음과 같이 구현할 수 있을 것 같습니다.\n\n또한 테스트가 끝나면 다른 테스트가 영향을 받지 않아야 하므로, `afterTestMethod()` 메서드도 다음과 같이 구현했습니다.\n\n```java\npublic class MockAuthTestExecutionListener implements TestExecutionListener {  \n  \n    @Override  \n    public void beforeTestMethod(TestContext testContext) throws Exception {  \n        Method testMethod = testContext.getTestMethod();  \n        if (testMethod.isAnnotationPresent(WithMockAuth.class)) {  \n            WithMockAuth withMockAuth = testMethod.getDeclaredAnnotation(WithMockAuth.class);  \n            ApplicationContext applicationContext = testContext.getApplicationContext();  \n            MockAuthExtractor authExtractor = applicationContext.getBean(MockAuthExtractor.class);  \n            authExtractor.setMemberId(withMockAuth.id());  \n            authExtractor.setRole(withMockAuth.role());  \n        }  \n    }\n\n    @Override  \n    public void afterTestMethod(TestContext testContext) throws Exception { \n        ApplicationContext applicationContext = testContext.getApplicationContext();  \n        MockAuthExtractor authExtractor = applicationContext.getBean(MockAuthExtractor.class);  \n        authExtractor.setMemberId(null);  \n        authExtractor.setRole(Role.ANONYMOUS);  \n    }\n}\n```\n\n그리고 이전에 만들었던 `@CustomWebMvcTest`에 `TestExecutionListener`를 사용하는 코드를 추가하면 모든 작업이 끝납니다.\n\n```java\n@WebMvcTest  \n@Import(TestAuthConfig.class)  \n@Retention(RetentionPolicy.RUNTIME)  \n@TestExecutionListeners(MockAuthTestExecutionListener.class) <--\npublic @interface CustomWebMvcTest {\n    ...\n}\n```\n\n하지만 테스트를 실행하면, 다음과 같은 예외가 발생하며 테스트가 실패합니다.\n\n```java\njava.lang.NullPointerException: Cannot invoke \"com.festago.application.StageService.create(com.festago.dto.StageCreateRequest)\" because \"this.stageService\" is null\n```\n\n왜냐하면 `@WebMvcTest`를 수행할 때, 기본적으로 등록된 `TestExecutionListener`가 있는데 `@TestExecutionListeners`를 새롭게 사용하면서 기존의 `TestExecutionListener`가 대체되었기 때문입니다.\n\n따라서 새로운 `TestExecutionListener`를 등록하면서 기존의 `TestExecutionListener`는 유지시켜야 합니다.\n\n이것은 `@TestExecutionListeners`의 `mergeMode` 속성으로 해결할 수 있습니다.\n\n```java\n@TestExecutionListeners(listeners = MockAuthTestExecutionListener.class, mergeMode = MergeMode.MERGE_WITH_DEFAULTS)\n```\n\n`@TestExecutionListeners`의 `mergeMode` 속성의 기본값은 `REPLACE_DEFAULTS` 입니다.\n\n따라서 `MERGE_WITH_DEFAULTS` 속성을 사용하여 기존의 `TestExecutionListener`를 대체하지 않고 새로운 `TestExecutionListener`를 추가할 수 있습니다.\n\n이제 인증, 인가가 필요한 테스트에 다음과 같은 어노테이션만 추가시키면 간편하게 인증, 인가 작업을 수행할 수 있습니다.\n\n```java\n@CustomWebMvcTest(AuthController.class)\nclass AuthControllerTest {\n    @Test\n    @WithMockAuth(role = Role.ADMIN)\n    void 멤버_권한이_아닌데_탈퇴하면_예외() throws Exception {\n        mockMvc.perform(delete(\"/auth\")\n                .header(\"Authorization\", \"Bearer token\")\n                .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isNotFound());\n    }\n\n    @Test\n    @WithMockAuth\n    void 회원_탈퇴를_한다() throws Exception {\n        mockMvc.perform(delete(\"/auth\")\n                .header(\"Authorization\", \"Bearer token\")\n                .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isOk());\n    }\n}\n```\n\n## 결론\n\n기존의 인증 방식에는 하나의 역할만 존재하여, 하나의 인증 방식만 사용하므로 단순한 방식의 인증 기능만 수행하면 됐습니다.\n\n하지만 관리자 또는 스태프같이 다양한 역할의 사용자가 추가되어 추가적인 인증 방식이 필요하게 됐습니다.\n\n따라서 새로운 인증 방식이 추가 되더라도 큰 변경 없이 인증 및 인가 작업이 필요하였고, 인증, 인가를 `Interceptor`에서 수행하도록 한 뒤, 토큰을 추출하고 토큰에서 인증 정보를 추출하는 책임을 가진 객체를 분리하여 재사용성이 높은 코드를 구현했습니다.\n\n또한 `@WebMvcTest` 테스트 코드에서 인증, 인가 작업으로 중복적으로 발생하게 되는 코드 또한 커스텀 어노테이션과 `TestExecutionListener`를 사용하여 중복된 코드를 해결할 수 있습니다.\n\n만약 `Request` 객체의 `Attribute`를 사용하고 싶지 않다면, `RequestScope` 범위를 가진 빈을 주입하여 해결할 수 있습니다.\n\n> `Attribute`에서 값을 꺼낼 때 Object 타입으로 추출이 되므로, 형변환 과정이 필요하고, 꺼낸 객체가 nullable 하므로 페스타고의 실제 코드에서는 `RequestScope` 범위의 빈을 사용하였습니다.\n"},{"excerpt":"서론 안녕하세요. 페스타고의 글렌입니다. 🥃 페스타고는 인증을 구현할 때, 최소한의 정보로 안전하게 인증을 구현할 수 있는 OAuth2를 채택하였습니다. OAuth2를 구현할 때 서비스를 제공하는 회사들은 매우 많습니다. 그중에서 저희가 선택한 OAuth2 제공자는  입니다. 카카오톡을 선택한 이유는 저희 서비스의 특성상 사용자 간의 티켓 거래를 막기 위…","fields":{"slug":"/oauth2-select-and-apply/"},"frontmatter":{"date":"August 20, 2023","title":"페스타고의 인증 - OAuth2를 선택하고 적용한 방법","tags":["OAuth2"]},"rawMarkdownBody":"\n## 서론\n\n안녕하세요.\n\n페스타고의 글렌입니다. 🥃\n\n페스타고는 인증을 구현할 때, 최소한의 정보로 안전하게 인증을 구현할 수 있는 OAuth2를 채택하였습니다.\n\nOAuth2를 구현할 때 서비스를 제공하는 회사들은 매우 많습니다.\n\n그중에서 저희가 선택한 OAuth2 제공자는 `카카오톡` 입니다.\n\n카카오톡을 선택한 이유는 저희 서비스의 특성상 사용자 간의 티켓 거래를 막기 위함인데요.\n\n구글이나 페이스북 등 쉽게 계정을 생성할 수 있는 서비스는 한 명의 사용자가 여러 계정을 통해 티켓을 예매할 수 있으므로, 국내에서 유일한 전화번호로 계정을 생성할 수 있는 서비스 제공자인 카카오톡을 선택하게 되었습니다.\n\n페스타고에서 구현한 OAuth2의 인증 플로우는 다음과 같습니다.\n\n![](images/20230819155223.png)\n\n이 방식은 `Authorization Code Grant Type`라고 불리는 OAuth2 인증 방식의 종류 중 하나입니다.\n\n해당 인증 방식은 사용자는 신뢰할 수 있는 OAuth2 인증 서버로 요청을 보내고, 인증 서버는 클라이언트(백엔드 스프링 서버)에 엑세스 토큰과 사용자 정보를 반환합니다.\n\n이러한 방식으로 사용자의 엑세스 토큰과 사용자 정보의 노출을 최소화할 수 있으므로 보안의 신뢰성이 높습니다.\n\n이러한 방식을 어떻게 코드로 구현하였는지 설명하겠습니다.\n\n코드로 구현할 클래스를 간략히 나타낸다면 한다면 다음과 같습니다.\n\n`SocialType`: Enum으로 OAuth2의 제공자를 나타냅니다. (ex: KAKAO)\n\n`AuthProvider`: 사용자 정보를 바탕으로 저희의 엑세스 토큰을 만들어 주는 역할을 합니다.\n\n`AuthExtractor`: 엑세스 토큰을 파싱하여 유효성을 검증하고 Payload의 값을 추출하는 역할을 합니다.\n\n`OAuth2Client`: OAuth2 인증, 리소스 서버로 요청을 보내고 엑세스 토큰, 사용자 정보 등 민감한 정보를 받는 역할을 합니다.\n\n`Member`: 사용자의 정보를 담고 있는 엔티티로, `SocialType`을 필드로 가지고 있습니다.\n\n`AuthService`: 인증을 수행하는 서비스 레이어 클래스입니다.\n\n여기서 `OAuth2Client`는 외부 API에 의존하므로, 인터페이스로 만들어 테스트나 로컬 환경에서 모의 객체를 만들 수 있도록 하였습니다.\n#### AuthProvider\n```java\npublic class JwtAuthProvider implements AuthProvider {  \n  \n    private static final int SECOND_FACTOR = 60;  \n    private static final int MILLISECOND_FACTOR = 1000;  \n    private static final String MEMBER_ID_KEY = \"memberId\";\n  \n    private final SecretKey key;  \n    private final long expirationMinutes;  \n  \n    public JwtAuthProvider(String secretKey, long expirationMinutes) {  \n        this.key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));  \n        this.expirationMinutes = expirationMinutes;  \n    }  \n  \n    @Override  \n    public String provide(AuthPayload authPayload) {  \n        Date now = new Date();  \n        return Jwts.builder()  \n            .claim(MEMBER_ID_KEY, authPayload.getMemberId())   \n            .setIssuedAt(now)  \n            .setExpiration(new Date(now.getTime() + expirationMinutes * SECOND_FACTOR * MILLISECOND_FACTOR))  \n            .signWith(key, SignatureAlgorithm.HS256)  \n            .compact();  \n    }  \n}\n```\n\nAuthProvider의 구현체인 `JwtAuthProvider` 입니다.\n\n`Member` 엔티티의 PK를 Payload에 넣어 JWT 토큰을 반환해 줍니다.\n\n해당 토큰은 앞으로 저희 서버에 인증 과정에 필요한 엑세스 토큰입니다.\n\n#### AuthExtractor\n```java\npublic class JwtAuthExtractor implements AuthExtractor {  \n  \n    private static final String MEMBER_ID_KEY = \"memberId\";  \n  \n    private final JwtParser jwtParser;  \n  \n    public JwtAuthExtractor(String secretKey) {  \n        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));  \n        this.jwtParser = Jwts.parserBuilder()  \n            .setSigningKey(key)  \n            .build();  \n    }  \n  \n    @Override  \n    public AuthPayload extract(String token) {  \n        Claims claims = getClaims(token);  \n        Long memberId = claims.get(MEMBER_ID_KEY, Long.class);  \n        return new AuthPayload(memberId);  \n    }  \n  \n    private Claims getClaims(String code) {  \n        try {  \n            return jwtParser.parseClaimsJws(code)  \n                .getBody();  \n        } catch (ExpiredJwtException e) {  \n            throw new UnauthorizedException(ErrorCode.EXPIRED_AUTH_TOKEN);  \n        } catch (JwtException | IllegalArgumentException e) {  \n            throw new UnauthorizedException(ErrorCode.INVALID_AUTH_TOKEN);  \n        }  \n    }  \n}\n```\n\nAuthExtractor의 구현체인 `JwtAuthExtractor` 입니다.\n\n토큰을 받아 `AuthPayload` 객체로 만들어 반환합니다.\n\n참고로 필드로 `JwtParser`를 가지고 있는데 이는 `Jwts.parserBuilder()` 메소드로 생성된 인스턴스는 불변하고, thread-safe 하기 때문입니다.\n\n![](images/20230818023037.png)\n\n따라서 다음과 같이 파싱할 때마다 인스턴스를 새롭게 만들지 않고, 기존의 인스턴스를 재사용할 수 있습니다.\n\n```java\n// 파싱마다 새로운 인스턴스 생성\nreturn Jwts.parserBuilder()  \n            .setSigningKey(key)  \n            .build()\n            .parseClaimsJws(code)  \n            .getBody();\n\n// 파싱마다 기존의 인스턴스 재사용\nreturn jwtParser.parseClaimsJws(code)  \n                .getBody();  \n```\n\n#### OAuth2Client\n```java\n@Component\npublic class KakaoOAuth2Client implements OAuth2Client {  \n  \n    private static final String ACCESS_TOKEN_URL = \"https://kauth.kakao.com/oauth/token\";  \n    private static final String USER_INFO_URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectId;  \n  \n    public KakaoOAuth2Client(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectId = redirectUri;  \n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.add(\"grant_type\", grantType);  \n        headers.add(\"client_id\", clientId);  \n        headers.add(\"redirect_uri\", redirectId);  \n        headers.add(\"code\", code);  \n  \n        try {  \n            KakaoAccessTokenResponse response = restTemplate.postForEntity(  \n                ACCESS_TOKEN_URL, headers,  \n                KakaoAccessTokenResponse.class).getBody();  \n            return response.accessToken();  \n        } catch (HttpClientErrorException e) {  \n            KakaoOAuth2Error kakaoOAuth2Error = e.getResponseBodyAs(KakaoOAuth2Error.class);  \n            if (kakaoOAuth2Error.isErrorCodeKOE320()) {  \n                throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n            }  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n  \n        try {  \n            KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                    KakaoUserInfo.class)  \n                .getBody();  \n            return UserInfo.ofKakao(kakaoUserInfo);  \n        } catch (HttpClientErrorException e) {  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }  \n  \n    public record KakaoOAuth2Error(  \n        String error,  \n        @JsonProperty(\"error_description\") String errorDescription,  \n        @JsonProperty(\"error_code\") String errorCode  \n    ) {  \n  \n        public boolean isErrorCodeKOE320() {  \n            return errorCode.equals(\"KOE320\");  \n        }  \n    }  \n}\n```\n\n실제 카카오 OAuth2 서비스 제공자에게 정보를 요청하는 `KakaoOAuth2Client` 입니다.\n\n코드에 지저분한 곳이 많고, 단일 책임 원칙을 지키지 않는 부분이 있습니다. (액세스 토큰 요청, 사용자 정보 요청)\n\n추후 이 부분을 어떻게 개선했는지 알려드리겠습니다.\n\n> record에 @JsonProperty를 사용한 이유는 [스택 오버플로우 링크](https://stackoverflow.com/questions/68394911/why-record-class-cant-be-properly-deserialized-with-jackson)에 나와 있습니다.\n\n#### AuthService\n```java\n@Service\n@Transactional\npublic class AuthService {  \n  \n    private final MemberRepository memberRepository;  \n    private final OAuth2Client oAuth2Client;  \n    private final AuthProvider authProvider;  \n  \n    public AuthService(MemberRepository memberRepository, OAuth2Client oAuth2Client, AuthProvider authProvider) {  \n        this.memberRepository = memberRepository;  \n        this.oAuth2Client = oAuth2Client;  \n        this.authProvider = authProvider;  \n    }  \n  \n    public LoginResponse login(String code) {  \n        String accessToken = oAuth2Client.getAccessToken(code);  \n        UserInfo userInfo = oAuth2Client.getUserInfo(accessToken);  \n        Member member = memberRepository.findBySocialIdAndSocialType(userInfo.socialId(), userInfo.socialType())  \n            .orElseGet(() -> memberRepository.save(userInfo.toMember()));  \n        return new LoginResponse(authProvider.provide(member), userInfo.nickname());  \n    }  \n}\n```\n\n컨트롤러에서 보내온 요청을 처리하는 서비스 클래스입니다.\n\n흐름은 맨 위에서 설명한 것과 같이 코드를 받아, OAuth2 서비스 제공자로부터 액세스 토큰을 얻고, 사용자 정보를 얻은 뒤 기존의 회원이 있으면 `AuthProvider`를 통해 액세스 토큰을 반환하고, 기존의 회원이 없다면 `orElseGet()` 메서드를 통해 회원을 생성하고 액세스 토큰을 반환합니다.\n\n---\n\n이렇게 구현한 방식에는 문제점이 있습니다.\n\n`OAuth2Client`의 코드를 보면 단일 책임 원칙을 지키지 못했고(액세스 코드와 사용자 정보를 모두 관리) 요청을 보낼 때 예외를 처리하기 위한 try-catch문 때문에 코드의 가독성이 나쁩니다.\n\n그리고 `OAuth2Client`를 인터페이스로 정의하여 변경에는 유연하게 대응했지만, 단일 인스턴스이기 때문에 다른 OAuth2 서비스 제공자가 추가될 경우 새로운 클래스 혹은 메소드가 필요합니다.\n\n### 단일 책임 원칙의 분리\n\n유명한 객체 지향 원칙인 SOLID 원칙에서 S는 단일 책임 원칙을 뜻합니다.\n\n스프링 프레임워크를 사용하며, 의존성 주입을 통한 OCP, DIP 원칙은 매우 쉽게 지킬 수 있으나, SRP 원칙은 구현하는 개발자가 객체가 가지는 책임을 얼마나 잘 구분할 수 있는지에 따라 달렸습니다.\n\nOAuth2Client는 두 가지 일을 처리합니다.\n1. 액세스 토큰을 요청\n2. 사용자 정보를 요청\n\n두 가지 일은 OAuth2 인증의 흐름으로는 하나의 작업으로 볼 수 있겠지만 객체가 가지는 책임은 두 가지 책임을 지고 있습니다.\n\n따라서, 엑세스 토큰만 요청하는 클래스와 사용자 정보만 요청하는 클래스로 나눠 설계할 수 있습니다.\n\n#### KakaoOAuth2AccessTokenClient\n```java\n@Component\npublic class KakaoOAuth2AccessTokenClient {  \n  \n    private static final String URL = \"https://kauth.kakao.com/oauth/token\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectUri;  \n  \n    public KakaoOAuth2AccessTokenClient(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,\n        @Value(\"${festago.oauth2.kakao.client-secret}\") String clientSecret,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectUri = redirectUri;  \n        this.clientSecret = clientSecret;\n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = getAccessTokenHeaders(code);  \n        return requestAccessToken(headers);  \n    }  \n  \n    private HttpHeaders getAccessTokenHeaders(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.set(\"grant_type\", grantType);  \n        headers.set(\"client_id\", clientId);  \n        headers.set(\"redirect_uri\", redirectUri);  \n        headers.set(\"client_secret\", clientSecret);\n        headers.set(\"code\", code);  \n        return headers;  \n    }  \n  \n    private String requestAccessToken(HttpHeaders headers) {  \n        try {  \n            KakaoAccessTokenResponse response = restTemplate.postForEntity(ACCESS_TOKEN_URL, headers,  \n                KakaoAccessTokenResponse.class).getBody();  \n            return response.accessToken();  \n        } catch (HttpClientErrorException e) {  \n            KakaoOAuth2Error kakaoOAuth2Error = e.getResponseBodyAs(KakaoOAuth2Error.class);  \n            if (kakaoOAuth2Error.isErrorCodeKOE320()) {  \n                throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n            }  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }\n}\n```\n\n#### KakaoOAuth2UserInfoClient\n```java\n@Component\npublic class KakaoOAuth2UserInfoClient {  \n  \n    private static final String URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n  \n    public KakaoOAuth2UserInfoClient(RestTemplateBuilder restTemplateBuilder) {  \n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = getUserInfoHeaders(accessToken);  \n        return requestUserInfo(headers);  \n    }  \n  \n    private HttpHeaders getUserInfoHeaders(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n        return headers;  \n    }  \n  \n    private UserInfo requestUserInfo(HttpHeaders headers) {  \n        try {  \n            KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                    KakaoUserInfo.class)  \n                .getBody();  \n            return kakaoUserInfo.toUserInfo();  \n        } catch (HttpClientErrorException e) {  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }\n    }\n}\n```\n\n그리고 기존의 `KakaoOAuth2Client`는 다음과 같이 코드를 수정할 수 있습니다.\n\n```java\n@Component  \npublic class KakaoOAuth2Client implements OAuth2Client {\n\n    private final KakaoOAuth2AccessTokenClient accessTokenClient;  \n    private final KakaoOAuth2UserInfoClient userInfoClient;\n    \n    public KakaoOAuth2Client(KakaoOAuth2AccessTokenClient accessTokenClient, KakaoOAuth2UserInfoClient userInfoClient) {  \n        this.accessTokenClient = accessTokenClient;  \n        this.userInfoClient = userInfoClient;  \n    }\n\n    public String getAccessToken(String code) {  \n        return accessTokenClient.getAccessToken(code)\n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        return userInfoClient.getUserInfo(accessToken);\n    }  \n}\n```\n\n이제부터 `KakaoOAuth2Client` 클래스는 책임을 분리한 클래스에 요청을 위임하는 역할을 합니다.\n\n#### ResponseErrorHandler\n\n하지만 아직도 여전히 추한 try-catch가 코드에 남아있습니다.\n\n`RestTemplate` 클래스에서 발생한 예외를 처리하기 위해 어쩔 수 없이 try-catch문을 사용해야 합니다.\n\n그런데 여기서 잠깐,\n\n저희는 스프링을 사용하며 컨트롤러, 서비스 레이어에 try-catch를 잘 사용하지 않습니다.\n\n오히려 예외를 처리하지 않고 던져버립니다.\n\n그러는 이유는 요청의 예외를 전역적으로 처리해 주는 `@ControllerAdvice`를 사용하기 때문입니다.\n\n`RestTemplate` 클래스에서도 `@ControllerAdvice` 같은 역할을 할 수 있는 클래스가 있습니다.\n\n바로 `ResponseErrorHandler` 입니다.\n\n`ResponseErrorHandler`는 인터페이스로 다음과 같은 두 개의 추상 메소드를 가지고 있습니다.\n\n```java\npublic interface ResponseErrorHandler {\n\n    boolean hasError(ClientHttpResponse response) throws IOException;\n    \n    void handleError(ClientHttpResponse response) throws IOException;\n}\n```\n\n사실 이미 `RestTemplate`에서는 기본적인 `ResponseErrorHandler`가 등록되어 있습니다.\n\n```java\npublic class RestTemplate extends InterceptingHttpAccessor implements RestOperations {\n    ...\n    private ResponseErrorHandler errorHandler = new DefaultResponseErrorHandler();\n    ...\n}\n```\n\n따라서 기존의 `ResponseErrorHandler`를 사용하지 않고 커스텀한 에러 핸들러를 만들어 사용하면 예외 처리에 관한 로직을 분리할 수 있습니다.\n#### KakaoOAuth2AccessTokenErrorHandler\n```java\npublic class KakaoOAuth2AccessTokenErrorHandler extends DefaultResponseErrorHandler {  \n  \n    @Override  \n    public void handleError(ClientHttpResponse response) throws IOException {  \n        try {  \n            super.handleError(response);  \n        } catch (HttpStatusCodeException e) {  \n            HttpStatusCode statusCode = response.getStatusCode();  \n            handle4xxError(statusCode, e);  \n            handle5xxError(statusCode);  \n        }  \n        throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR);  \n    }  \n  \n    private void handle4xxError(HttpStatusCode statusCode, HttpStatusCodeException e) {  \n        if (statusCode.is4xxClientError()) {  \n            KakaoOAuth2ErrorResponse errorResponse = e.getResponseBodyAs(KakaoOAuth2ErrorResponse.class);  \n            handleErrorCode(errorResponse);  \n        }  \n    }  \n  \n    private void handleErrorCode(KakaoOAuth2ErrorResponse errorResponse) {  \n        handleKOE320Error(errorResponse);  \n        throw new InternalServerException(ErrorCode.OAUTH2_INVALID_REQUEST);  \n    }  \n  \n    private void handleKOE320Error(KakaoOAuth2ErrorResponse errorResponse) {  \n        if (errorResponse != null && errorResponse.isErrorCodeKOE320()) {  \n            throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n        }  \n    }  \n  \n    private void handle5xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is5xxServerError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_PROVIDER_NOT_RESPONSE);  \n        }  \n    }  \n  \n    public record KakaoOAuth2ErrorResponse(  \n        String error,  \n        @JsonProperty(\"error_description\") String errorDescription,  \n        @JsonProperty(\"error_code\") String errorCode  \n    ) {  \n  \n        public boolean isErrorCodeKOE320() {  \n            return Objects.equals(errorCode, \"KOE320\");  \n        }  \n    }  \n}\n```\n\n#### KakaoOAuth2UserInfoErrorHandler\n```java\npublic class KakaoOAuth2UserInfoErrorHandler extends DefaultResponseErrorHandler {  \n  \n    @Override  \n    public void handleError(ClientHttpResponse response) throws IOException {  \n        HttpStatusCode statusCode = response.getStatusCode();  \n        handle4xxError(statusCode);  \n        handle5xxError(statusCode);  \n        throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR);  \n    }  \n  \n    private void handle4xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is4xxClientError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_INVALID_REQUEST);  \n        }  \n    }  \n  \n    private void handle5xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is5xxServerError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_PROVIDER_NOT_RESPONSE);  \n        }  \n    }  \n}\n```\n\n해당 에러 핸들러를 적용한 OAuth2Client는 다음과 같이 코드가 변경됩니다.\n#### KakaoOAuth2AccessTokenClient\n```java\n@Component\npublic class KakaoOAuth2AccessTokenClient {  \n  \n    private static final String URL = \"https://kauth.kakao.com/oauth/token\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectUri;  \n  \n    public KakaoOAuth2AccessTokenClient(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,\n        @Value(\"${festago.oauth2.kakao.client-secret}\") String clientSecret,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectUri = redirectUri;  \n        this.clientSecret = clientSecret;\n        this.restTemplate = restTemplateBuilder\n            .errorHandler(new KakaoOAuth2AccessTokenErrorHandler())\n            .build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = getAccessTokenHeaders(code);  \n        return requestAccessToken(headers);  \n    }  \n  \n    private HttpHeaders getAccessTokenHeaders(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.set(\"grant_type\", grantType);  \n        headers.set(\"client_id\", clientId);  \n        headers.set(\"redirect_uri\", redirectUri);  \n        headers.set(\"client_secret\", clientSecret);\n        headers.set(\"code\", code);  \n        return headers;  \n    }  \n  \n    private String requestAccessToken(HttpHeaders headers) {  \n        KakaoAccessTokenResponse response = restTemplate.postForEntity(ACCESS_TOKEN_URL, headers,  \n            KakaoAccessTokenResponse.class).getBody();  \n        return response.accessToken();  \n    }\n}\n```\n\n#### KakaoOAuth2UserInfoClient\n```java\n@Component\npublic class KakaoOAuth2UserInfoClient {  \n  \n    private static final String URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n  \n    public KakaoOAuth2UserInfoClient(RestTemplateBuilder restTemplateBuilder) {  \n        this.restTemplate = restTemplateBuilder\n            .errorHandler(new KakaoOAuth2UserInfoErrorHandler())\n            .build();  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = getUserInfoHeaders(accessToken);  \n        return requestUserInfo(headers);  \n    }  \n  \n    private HttpHeaders getUserInfoHeaders(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n        return headers;  \n    }  \n  \n    private UserInfo requestUserInfo(HttpHeaders headers) {  \n        KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                KakaoUserInfo.class)  \n            .getBody();  \n        return kakaoUserInfo.toUserInfo();  \n    }\n}\n```\n\n이처럼 예외를 처리하는 책임을 가진 객체로 분리하여, 요청을 보내는 객체에는 예외를 처리하는 코드 하나 없이 오로지 비즈니스 로직만 남게 된 것을 볼 수 있습니다.\n\n### 새로운 OAuth2 클라이언트의 추가\n\n서비스에서 사용하는 `OAuth2Client`는 인터페이스입니다.\n\n인터페이스로 설계하여, OAuth2 서비스 제공자가 바뀌더라도 쉽게 교체할 수 있고, 모의 OAuth2Client 객체를 만들어서 테스트할 때 외부 API의 연동 없이 테스트할 수 있습니다.\n\n하지만 이렇게 인터페이스를 사용하도록 만들어도, 인스턴스의 필드가 하나이기 때문에 추가적인 OAuth2Client를 사용하려면 서비스 제공자마다 서비스 클래스를 만들거나, 필드와 메소드가 생길 것입니다.\n\n```java\npublic class KakaoOAuth2Service{\n    ...\n};\n\npublic class NaverOAuth2Service{\n    ...\n};\n\n// 또는\n\npublic class AuthService {\n\n    private final OAuth2Client kakaoOAuth2Client;\n    private final OAuth2Client naverOAuth2Client;\n    \n    public void loginKakaoOAuth2(String code) {\n        ...\n    }\n    public void loginKakaoOAuth2(String code) {\n        ...\n    }\n}\n```\n\n이것은 단일 책임 원칙을 지켰다고 할 수 있겠지만, 중복된 코드가 생기게 되고 새로운 서비스 제공자가 생길 때 새로운 메소드를 추가해 줘야 합니다.\n\n그렇다면 어떻게 하나의 필드로 여러 `OAuth2Client`를 사용할 수 있을까요?\n\n스프링은 의존성을 주입할 때 컬렉션으로 의존성을 주입해 주는 기능을 제공합니다.\n\n따라서 다음과 같이 여러 `OAuth2Client`를 `List` 형식으로 받을 수 있습니다.\n\n```java\npublic class AuthService {\n\n    private final List<OAuth2Client> oAuth2Clients;\n\n    public AuthService(List<OAuth2Client> oAuth2Clients) {\n        this.oAuth2Clients = oAuth2Clients;\n    }\n}\n```\n\n이것이 바로 인터페이스를 의존하게 하면 얻을 수 있는 강력한 이점 중 하나입니다.\n\n그런데, 단순히 List 타입으로 받았다고 해서 끝나는 것은 아닙니다.\n\n리스트 중에서 사용자가 원하는 서비스 제공자를 선택할 수 있어야 합니다.\n\n```java\npublic OAuth2Client getClient(SocialType socialType) {\n    return oAuth2Clients.stream()\n        .filter(client -> client.getSocialType == socialType)\n        .findAny()\n        .orElseThrow(() -> BadRequestException(...));\n}\n```\n\n이렇게 Stream을 활용해서 사용자가 원하는 서비스 제공자를 선택할 수 있겠지만, 매번 Stream을 사용하여 원하는 서비스 제공자를 찾는 작업은 비효율적입니다.\n\n이때는 List 자료구조를 사용하는 것 보다 Map 자료구조를 사용하면 효율적일 것입니다.\n\n스프링은 Map 타입으로도 의존성 주입을 제공합니다.\n\n하지만 Map으로 의존성을 주입받으면 Key가 String인 `kakaoOAuth2Client`와 같이 지정됩니다.\n\n```java\nprivate final Map<String, OAuth2Client> oAuth2ClientMap;\n```\n\n따라서 다음과 같이 의존성 주입은 List로 받은 뒤, 내부에서 Map으로 변환시키면 Key가 Enum 타입인 Map을 사용할 수 있습니다.\n\n```java\nprivate final Map<SocialType, OAuth2Client> oAuth2ClientMap = new EnumMap<>(SocialType.class);\n\npublic AuthService(List<OAuth2Client> oAuth2Clients) {\n    for (OAuth2Client oAuth2Client: oAuth2Clients) {\n        oAuth2ClientMap.put(oAuth2Client.getSocialType(), oAuth2Client);\n    }\n}\n```\n\n이제 다음과 같이 특정 클라이언트를 빠르게 찾아올 수 있습니다.\n\n```java\npublic OAuth2Clients getOAuth2Client(SocialType socialType) {\n    return Optional.ofNullable(oAuth2ClientMap.get(socialType))  \n        .orElseThrow(() -> new BadRequestException(...));\n}\n```\n\n하지만 이것 또한 완벽하게 해결한 것은 아닙니다.\n\n필드에 `OAuth2Client`에 대한 자료구조가 그대로 노출이 되고 있습니다.\n\n`AuthService` 클래스에서 필요한 기능은 SocialType에 맞는 OAuth2Client만 선택하는 것입니다.\n\n`AuthService` 클래스는 Map에 대한 기능을 자세히 알 필요는 없습니다.\n\n이것은 저희가 레벨1부터 배워온 방법을 사용하면 쉽게 해결할 수 있습니다.\n\n바로 `일급 컬렉션`으로 만드는 것입니다.\n\n```java\n@Component\npublic class OAuth2Clients {\n    private final Map<SocialType, OAuth2Client> oAuth2ClientMap = new EnumMap<>(SocialType.class);\n\n    public OAuth2Clients(List<OAuth2Client> oAuth2Clients) {\n        for (OAuth2Client oAuth2Client: oAuth2Clients) {\n            oAuth2ClientMap.put(oAuth2Client.getSocialType(), oAuth2Client);\n        }\n    }\n\n    public OAuth2Client getClient(SocialType socialType) {\n        return Optional.ofNullable(oAuth2ClientMap.get(socialType))  \n            .orElseThrow(() -> new BadRequestException(...));\n    }\n}\n```\n\n그리고 `AuthService`의 코드는 다음과 같이 변합니다.\n\n```java\n@Service\n@Transactional\npublic class AuthService {\n    private final OAuth2Clients oAuth2Clients;\n\n    ...\n\n    public LoginResponse login(SocialType socialType, String code) {  \n        OAuth2Client oAuth2Client = oAuth2Clients.getClient(socialType);\n        String accessToken = oAuth2Client.getAccessToken(code);  \n        UserInfo userInfo = oAuth2Client.getUserInfo(accessToken);  \n        Member member = memberRepository.findBySocialIdAndSocialType(userInfo.socialId(), socialType)  \n            .orElseGet(() -> memberRepository.save(userInfo.toMember()));  \n        return new LoginResponse(authProvider.provide(member), userInfo.nickname());  \n    }  \n} \n```\n\n이제 새로운 OAuth2Client가 추가되어도 기존의 코드를 변경할 필요는 전혀 없어집니다.\n\n또한 로컬 환경 또는 테스트 환경을 위한 모의 OAuth2Client를 만들더라도 `@Profile`  어노테이션의 사용으로 운영 환경에서는 전혀 영향을 주지 않게 할 수 있습니다.\n\n```java\n@Component  \n@Profile(\"!prod\")  \npublic class FestagoOAuth2Client implements OAuth2Client {  \n  \n    private static final String PROFILE_IMAGE = \"https://placehold.co/150x150\";  \n  \n    private final Map<String, UserInfo> userInfoMap = new HashMap<>();  \n  \n    public FestagoOAuth2Client() {  \n        userInfoMap.put(\"1\", new UserInfo(\"1\", getSocialType(), \"member1\", PROFILE_IMAGE));  \n        userInfoMap.put(\"2\", new UserInfo(\"2\", getSocialType(), \"member2\", PROFILE_IMAGE));  \n        userInfoMap.put(\"3\", new UserInfo(\"3\", getSocialType(), \"member3\", PROFILE_IMAGE));  \n    }  \n  \n    @Override  \n    public UserInfo getUserInfo(String accessToken) {  \n        return Optional.ofNullable(userInfoMap.get(accessToken))\n            .orElseThrow(() -> new BadRequestException(...));\n    }  \n  \n    @Override  \n    public SocialType getSocialType() {  \n        return SocialType.FESTAGO;  \n    }  \n}\n```\n\n## 결론\n\nOAuth2를 사용한 인증 기능을 구현할 때, 스프링이 제공하는 의존성 주입 기능과 인터페이스를 사용한 다형성 활용 등, 객체 지향 설계를 따라 코드를 구현하면 변경에 유연하고 가독성이 높은 코드를 만들 수 있습니다.\n\n저희 서비스 특성상 새로운 OAuth2 서비스 제공자가 추가될 확률은 낮겠지만, 레벨 1, 2 과정을 배우며 습득한 객체 지향 설계 원칙을 이렇게 서비스에 녹여냈다는 점이 뿌듯한 것 같습니다.\n\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}