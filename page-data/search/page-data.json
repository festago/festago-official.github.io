{"componentChunkName":"component---src-pages-search-jsx","path":"/search/","result":{"data":{"allMarkdownRemark":{"nodes":[{"excerpt":"안녕하세요. 페스타고의 베르입니다. 페스타고 앱을 개발하면서 LiveData 를 StateFlow 와 SharedFlow 로 리팩터링 했습니다. 리팩터링한 이유, 과정 그리고 어려웠던 점까지 공유하려고 합니다. Festago 를 개발하면서 ViewModel 의 UiState 및 Event 를 감지하기 위해 LiveData 를 사용했다.  이상적으로 Vie…","fields":{"slug":"/livedata-to-flow/"},"frontmatter":{"date":"October 11, 2023","title":"Refactoring LiveData to Flow","tags":["Android","LiveData","Flow","StateFlow","SharedFlow","Test"]},"rawMarkdownBody":"\n---\n\n안녕하세요. 페스타고의 베르입니다.\n\n페스타고 앱을 개발하면서 LiveData 를 StateFlow 와 SharedFlow 로 리팩터링 했습니다. 리팩터링한 이유, 과정 그리고 어려웠던 점까지 공유하려고 합니다.\n\n---\n\nFestago 를 개발하면서 ViewModel 의 UiState 및 Event 를 감지하기 위해 LiveData 를 사용했다.\n\n![](images/image.png)\n\n이상적으로 ViewModel 은 Android 를 알아선 안된다. 테스트 가능성, 메모리 누수 안전성, 모듈성을 향상시킨다.\n\n참고: AndroidDevelopers 블로그\n\nhttps://medium.com/androiddevelopers/viewmodels-and-livedata-patterns-antipatterns-21efaef74a54\n\n이를 이유로 안드로이드 의존성을 갖는 LiveData 를 사용하던 기존 코드들을 Kotlin 의존성을 갖는 Flow 로 Migration 해보기로 했다.\n\nStateFlow 와 SharedFlow 에 대한 이론적인 글은 개인 블로그 글을 참고해주세요.\n\nhttps://seonghoonc.tistory.com/30\n\n## 화면 소개\n\nMigration 할 학교 인증(StudentVerification)을 하는 화면이다.\n\n![](images/image-1.png)\n\n1. Activity 를 시작하면 학교 ID 로 학교 이메일을 받아온다\n2. 인증 번호 확인에 성공, 실패, 타임아웃 등 이벤트를 발생시킨다.\n\n## UiState LiveData to StateFlow\n\n```kotlin\nsealed interface StudentVerificationUiState {\n\t\t// 로딩 상태\n    object Loading : StudentVerificationUiState\n\n\t\t// 성공 상태\n    data class Success(\n        val schoolEmail: String,\n        val remainTime: Int,\n        val isValidateCode: Boolean = false,\n    ) : StudentVerificationUiState\n\n\t\t// 에러 상태\n    object Error : StudentVerificationUiState\n\n\t...\n}\n```\n\nuiState 는 위와 같이 sealed interface 로 정의된다. 로딩, 성공, 실패 상태가 있으며 그에 따라 각각 다른 화면을 보여준다.\n\n```kotlin\nclass StudentsVerificationViewModel(\n    private val schoolRepository: SchoolRepository,\n\t  // ...\n) : ViewModel() {\n\n\t\t// 로딩 상태로 초기화\n    private val _uiState = MutableLiveData<StudentVerificationUiState>(StudentVerificationUiState.Loading)\n    val uiState: LiveData<StudentVerificationUiState> = _uiState\n\n    fun loadSchoolEmail(schoolId: Int) {\n\t\t\t\t...\n        viewModelScope.launch {\n            schoolRepository.loadSchoolEmail(schoolId)\n\t\t\t\t\t\t\t\t// 성공하면 성공 상태로 set\n                .onSuccess { email ->\n                    _uiState.value = StudentVerificationUiState.Success(\n                        schoolEmail = email,\n                        remainTime = MIN_REMAIN_TIME,\n                    )\n                }\n\t\t\t\t\t\t\t\t// 실패하면 에러 상태로 set\n                .onFailure {\n                    _uiState.value = StudentVerificationUiState.Error\n                    // ...\n                } \n        }\n    }\n```\n\n이때 ViewModel 의 loadSchoolEmail() 을 호출하면 repository 로 학교 이메일을 요청하고 결과에 따라UiState 를 업데이트한다.\n\n이를 StateFlow 로 바꾸면?\n\n```kotlin\nclass StudentsVerificationViewModel(\n    private val schoolRepository: SchoolRepository,\n    //...\n) : ViewModel() {\n    // 로딩 상태로 초기화 LiveData 와 달리 초기값이 필수다.\n    private val _uiState = MutableStateFlow<StudentVerificationUiState>(StudentVerificationUiState.Loading)\n    val uiState: StateFlow<StudentVerificationUiState> = _uiState.asStateFlow()\n\t\n\n```\n\nViewModel 에서 코드는 거의 비슷하다! StateFlow 는 초기 값을 필수로 지정해줘야 한다. 그것 말고는 별 다른게 없다.\n\nActivity 에서는 다음과 같이 변경해야한다.\n\n1. observe 를 collect 로 변경한다.\n2. Lifecycle 변경을 감지할 수 있도록 처리한다.\n\n```kotlin\n\nlifecycleScope.launch {\n        repeatOnLifecycle(Lifecycle.State.STARTED) {\n\t\t\t\t\t\tviewModel.uiState.collect { uiState ->\n                handleUiState(uiState)\n            }\n        }\n    }\n```\n\nstateFlow 는 LiveData 와 달리 알아서 LifeCycle 을 감지하지 못한다.\n\n홈 화면을 누르거나 다른 액티비티에 가리는 등 생명주기가 Stopped 상태일 때 계속해서 collect 하고 있지 않도록 repeatOnLifecycle 을 사용해 처리했다.\n\n이 과정에서 ViewModel 테스트는 어떻게 되었을까?\n\n### ViewModel Test with LiveData\n\n기존 LiveData 사용 시 테스트다. 테스트에 관한 자세한 얘기는 생략하겠다.\n\n```kotlin\n@get:Rule\nval instantExecutorRule = InstantTaskExecutorRule()\n\n@Test\nfun `이메일 불러오기에 실패하면 실패 상태가 된다`() {\n    // given\n    `이메일 요청 결과가 다음과 같을 때`(Result.failure(Exception()))\n\n    // when\n    viewModel.loadSchoolEmail(schoolId)\n\n    // then : \n    assertThat(viewModel.uiState.value).isExactlyInstanceOf(StudentVerificationUiState.Error::class.java)\n}\n```\n\nViewModel 의 uiState 의 value 가져와 검증한다.\n\n안드로이드 의존성을 갖는 LiveData 를 ViewModel 에서 사용하면 ViewModel 을 단위 테스트하기 위해 Rule을 추가해줘야 한다.\n\n### ViewModel Test with StateFlow\n\n테스트를 짜다보면 리팩터링 할 때 기존 테스트코드에 빨간줄이 생기는 경험을 하게된다. 하지만 이 경우엔 없다!\n\nvalue 로 뽑아서 가져오는 방식이 LiveData 와 똑같기 때문이다.\n\n**더 이상 사용하지 않는 Rule 만 제거해주면 된다.**\n\n## Event 처리 LiveData to SharedFlow\n\nEvent Wrapping class 를 사용한 커스텀 SingleLiveData 를 사용하고 있었다.\n\n그 이유는 다음 글로 확인하길 바란다.\n\nhttps://festago.github.io/event-singlelivedata/\n\n```kotlin\nprivate val _event = MutableSingleLiveData<StudentVerificationEvent>()\nval event: SingleLiveData<StudentVerificationEvent> = _event\n\nfun confirmVerificationCode() {\n    viewModelScope.launch {\n        // ...\n        studentVerificationRepository.requestVerificationCodeConfirm(...)\n            .onSuccess {\n                _event.setValue(StudentVerificationEvent.VerificationSuccess)\n            }.onFailure {\n            _event.setValue(StudentVerificationEvent.VerificationFailure)\n         }\n     }\n\n```\n\n발생시키고 싶은 Event 가 있다면 MutableSingleLiveData 의 value 를 set 하면 된다.\n\n```kotlin\nprivate val _event = MutableSharedFlow<StudentVerificationEvent>()\nval event: SharedFlow<StudentVerificationEvent> = _event.asSharedFlow()\n\nfun confirmVerificationCode() {\n\t\tviewModelScope.launch {\n\t\t\t...\n\t      studentVerificationRepository.requestVerificationCodeConfirm(...)\n\t\t\t\t.onSuccess {\n            _event.emit(StudentVerificationEvent.VerificationSuccess)\n         }.onFailure {\n            _event.emit(StudentVerificationEvent.VerificationFailure)\n         }\n     }\n```\n\n하지만 sharedFlow 는 value 를 사용하지 않는다. 발생시키고 싶은 Event 가 있다면 emit 을 해주면 된다.\n\n```kotlin\nlifecycleScope.launch {\n        repeatOnLifecycle(Lifecycle.State.STARTED) {\n            viewModel.event.collect { event ->\n                handleEvent(event)\n            }\n        }\n    }\n```\n\nevent 도 마찬가지로 Lifecycle 에 맞춰 동작하기 위해 위와 같은 이유로 repeatOnLifecycle 을 적용했다.\n\n여기까진 아무 문제가 없었다. 하지만 테스트에서 몇가지 문제가 발생했다.\n\n### ViewModelTest with SharedFlow\n\n**문제점 1.  sharedFlow 는 getValue() 로 값을 얻어올 수 없다.**\n\nsharedFlow 는 LiveData 혹은 StateFlow 와 다르게 value 를 가져올 수 없다.  그렇기 때문에 방출되는 값을 반환받을 방법이 필요했다.\n\n해결 방법 : Flow 의 first() 확장함수 사용\n\n![](images/image-2.png)\n\nfirst 의 내부 구조를 보면 알 수 있듯  이 함수는 방출되는 가장 첫번째 값을 반환하며 일정 시간동안 방출되지 않으면 NoSuchElementException() 을 발생시킨다.\n\n```kotlin\n@Test\nfun `... 인증 번호 확인이 성공하면 인증 성공 이벤트가 발생한다`() = runTest {\n        // given\n        // ...\n\n        // when\n        viewModel.confirmVerificationCode()\n\n        // then\n        assertThat(vm.event.first()).isEqualTo(StudentVerificationEvent.VerificationSuccess)\n    }\n```\n\nflow 는 코루틴 위에서 동작한다. 따라서 suspend function 인 first() 를 사용하려면 runTest 를 사용해 TestScope 를 열어줘야 한다.\n\n하지만 이것은 곧바로 다음 문제를 직면한다.\n\n**문제점 2. sharedFlow 가 값을 방출할 때 까지 기다리지 않는다.**\n\n이전의 코드는 처음으로 방출된 event 를 받아오지만 viewModel.confirmVerificationCode() 와 vm.event.first() 가 동기적으로 실행된다. 실제로 방출된 이후 값을 기다리게 되어 기다리기만 하다가 결국 예외가 발생한다.\n\n값이 들어올 때 까지 기다리게 하기 위해서 async scope 를 열고 값이 반환된 후에 assertThat 검증이 실행되도록 변경하였다.\n\n```kotlin\n@Test\nfun `given ... 인증 번호 확인이 성공하면 인증 성공 이벤트가 발생한다`() = runTest(UnConfinedTestDispather()) {\n        // given\n        // ...\n\n        // sharedFlow Event 기다리기\n        val deferredEvent = async {\n            vm.event.first()\n        }\n\n        // when\n        viewModel.confirmVerificationCode()\n\n        // then\n        assertThat(deferredEvent.await()).isEqualTo(...)\n    }\n```\n\n이렇게 하면 처음으로 방출되는 이벤트가 반환될 때까지 기다렸다가 검증하여 테스트가 정상적으로 작동한다.\n\n이때 주의할 점은 테스트의 즉각적인 실행을 위해 UnConfinedTestDispatcher 를 사용해야 한다.\n\n- UnConfinedTesDispatcher : 코루틴 빌더가 반환될 때까지 기다리지 않고 즉시 실행해 예상 가능한 결과를 테스트할 수 있다.\n\n테스트의 정상 작동은 확인했지만 그래도 아직 마음에 들지 않는다.\n\n**문제점3. 테스트는 편리해야 한다.**\n\n매번 deferred  type 으로 기다리게 하고 await 으로 값을 체크하는 것은 용납할 수 없는 불편함이다. 그러다 찾은 것이 바로 turbine 이다.\n\nturbine 은 Flow Test third-party 라이브러리로 공식문서에서 편리한 Flow 테스트를 위해 사용해라고 소개되어있다.\n\nhttps://developer.android.com/kotlin/flow/test\n\nhttps://github.com/cashapp/turbine\n\n이 turbine 라이브러리를 사용하면 turbine 스코프를 열 수 있는데 이를 사용하면 훨씬 간단하게 위의 테스트를 진행할 수 있다.\n\n```kotlin\n@Test\nfun `... 인증 번호 확인이 성공하면 인증 성공 이벤트가 발생한다`() = runTest {\n        // given\n        ...\n\n\t\t\t\t**vm.event.test { // turbineScope**\n        \n        // when\n\t\t\t\tviewModel.confirmVerificationCode()\n\n**            // then\n            assertThat(awaitItem()).isEqualTo(...)\n            cancelAndIgnoreRemainingEvents()\n        }\n    }\n```\n\ntest turbine 스코프 내에서 awaitItem() 을 사용할 때마다 방출되는 값을 받을 수 있고 cancelAndIgnoreRemainingEvents() 를 사용해  남은 이벤트를 받지 않고 코루틴 스코프를 cancel 할 수 있다.\n\n아무 이벤트도 일어나지 않음을 테스트하려면 `expectNoEvents() 를 사용하면 된다.`\n\n![](images/image-3.png)\n\n추가적으로 Turbine 은 UnconfinedTestDispatcher 에 의존하고 있다. 이는 테스트를 더 쉽게 만들지만 이를 인지하고 사용해야 한다.\n\n다음은 학습을 위해 작성한 테스트 코드이다.\n\n```kotlin\nclass SharedFlowTest {\n\n    private val _sharedFlow = MutableSharedFlow<Int>(replay = 0)\n    val sharedFlow = _sharedFlow.asSharedFlow()\n\n    // 실패\n    @Test\n    fun `test sharedFlow in StandardTestDispatcher`() = runTest {\n        // when\n        _sharedFlow.emit(1)\n\n        // then\n        assertThat(sharedFlow.first()).isEqualTo(1)\n    }\n\n    // 실패\n    @OptIn(ExperimentalCoroutinesApi::class)\n    @Test\n    fun `test sharedFlow in UnconfinedTestDispatcher`() = runTest(UnconfinedTestDispatcher()) {\n        // when\n        _sharedFlow.emit(1)\n\n        // then\n        assertThat(sharedFlow.first()).isEqualTo(1)\n    }\n\n    // 실패\n    @Test\n    fun `test sharedFlow with async in StandardTestDispatcher`() = runTest {\n        val deferred = async {\n            sharedFlow.first()\n        }\n        // when\n        _sharedFlow.emit(1)\n\n        // then\n        assertThat(deferred.await()).isEqualTo(1)\n    }\n\n    // 성공\n    @OptIn(ExperimentalCoroutinesApi::class)\n    @Test\n    fun `test sharedFlow with async in UnconfinedTestDispatcher`() = runTest(UnconfinedTestDispatcher()) {\n        val deferred = async {\n            sharedFlow.first()\n        }\n        // when\n        _sharedFlow.emit(1)\n\n        // then\n        assertThat(deferred.await()).isEqualTo(1)\n    }\n\n    // 성공\n    @Test\n    fun `test sharedFlow with turbine in StandardTestDispatcher`() = runTest {\n        sharedFlow.test {\n            // when\n            _sharedFlow.emit(1)\n\n            // then\n            assertThat(awaitItem()).isEqualTo(1)\n        }\n    }\n\n\t\t// 성공\n    @OptIn(ExperimentalCoroutinesApi::class)\n    @Test\n    fun `test sharedFlow with turbine in UnconfinedTestDispatcher`() = runTest(UnconfinedTestDispatcher()) {\n        sharedFlow.test {\n            // when\n            _sharedFlow.emit(1)\n\n            // then\n            assertThat(awaitItem()).isEqualTo(1)\n        }\n    }\n```\n\n이 결과를 확인하면 더 쉽게 이해할 수 있을 것이다.\n\n## 해당 PR 링크\n\nhttps://github.com/woowacourse-teams/2023-festa-go/pull/429\n\n### 다른 화면 리팩터링\n\nhttps://github.com/woowacourse-teams/2023-festa-go/pull/493\nhttps://github.com/woowacourse-teams/2023-festa-go/pull/494\nhttps://github.com/woowacourse-teams/2023-festa-go/pull/495"},{"excerpt":"안녕하세요. 페스타고의 해시입니다. 페스타고 앱을 개발하면서 다른 액티비티로 넘어가거나 토스트를 띄우는 등의 이벤트를 어떻게 처리할지를 고민하게 되었고, 이러한 이벤트를 처리하기 위해 시도했던 방법과 겪었던 문제점, 그리고 해결 방법에 대해 다루려 합니다. 먼저 어떤 상황에서 이벤트가 발생하는지 코드를 통해 살펴보자. 뷰모델에서 로그인 여부를 확인해 로그…","fields":{"slug":"/event-singlelivedata/"},"frontmatter":{"date":"September 19, 2023","title":"LiveData로 이벤트 처리하기: SingleLiveData","tags":["Android","Event","SingleLiveData"]},"rawMarkdownBody":"\n안녕하세요. 페스타고의 해시입니다.\n\n페스타고 앱을 개발하면서 다른 액티비티로 넘어가거나 토스트를 띄우는 등의 이벤트를 어떻게 처리할지를 고민하게 되었고, 이러한 이벤트를 처리하기 위해 시도했던 방법과 겪었던 문제점, 그리고 해결 방법에 대해 다루려 합니다.\n\n---\n\n먼저 어떤 상황에서 이벤트가 발생하는지 코드를 통해 살펴보자.\n\n뷰모델에서 로그인 여부를 확인해 로그인된 사용자가 아닌 경우 SignInActivity로 이동한다.\n\n```kotlin\n// MyPageViewModel\n\nfun loadUserInfo() {\n    if (!authRepository.isSigned) {\n        // SignInActivity로 이동!\n    }\n    viewModelScope.launch {\n        // 유저 정보 불러오기\n    }\n}\n```\n\n사용자가 마이페이지에서 회원 탈퇴를 한 경우 첫 화면으로 이동해 앱의 첫 화면에서 재시작 하도록 한다.\n\n```kotlin\n// MyPageViewModel\n\nfun deleteAccount() {\n    viewModelScope.launch {\n        authRepository.deleteAccount()\n            .onSuccess {\n                // 첫 화면으로 이동\n            }.onFailure {\n                // ...\n            }\n    }\n}\n```\n\n위 두 예시처럼 뷰모델에서 이벤트가 발생하는 경우가 있다. 이벤트는 뷰모델의 메서드에서 발생하지만 다른 액티비티를 열거나 다이얼로그를 띄우는 등 이벤트에 대한 처리는 액티비티나 프래그먼트에서 이루어져야 한다.\n\n이런 이벤트를 처리하기 위해 LiveData를 활용할 수 있다. Flow를 사용해 뷰모델에서 안드로이드 의존성을 제거하는 것도 좋은 방법이지만 Flow는 다음 포스트에서 다루도록 하고, 이번 포스트에서는 LiveData를 다루려 한다.\n\n## LiveData로 이벤트 처리하기\n\n뷰모델에 라이브데이터를 두고, 액티비티나 프래그먼트에서 이를 observe 하여 이벤트를 처리할 수 있다.\n\n```kotlin\nclass MyPageViewModel(\n    // ...\n) : ViewModel() {\n\n    private val _showSignInEvent = MutableLiveData<Boolean>()\n    val showSignInEvent: LiveData<Boolean> get() = _showSignInEvent // 1\n\n\t\t// ...\n\n\t\tfun showSignIn() { // 3\n        _showSignInEvent.value = true // 4\n    }\n}\n```\n\n```kotlin\n// MyPageFragment\n\nvm.showSignInEvent.observe(viewLifecycleOwner) { event -> // 2\n    if (event) {\n        startActivity(SignInActivity.getIntent(requireContext())) // 5\n    }\n}\n```\n\n이벤트가 처리되는 플로우를 나열해 보면 다음과 같다.\n\n1. 뷰모델에 LiveData<Boolean> 타입의 showSignInEvent가 있다.\n2. 프래그먼트에서 showSignInEvent를 observe 한다.\n3. 뷰모델의 showSignIn()이 호출된다.\n4. showSignInEvent의 값이 true로 변경된다.\n5. showSignInEvent 값이 true로 변경되어 이를 observe 하는 프래그먼트에서 startActivity()가 실행된다.\n\n### 문제점\n\n그냥 LiveData로 이벤트를 처리하면 이벤트가 중복으로 발생되는 문제가 있다. 액티비티 이동은 이벤트가 발생했을 때 한 번 이루어져야 하는데 showSignInEvent를 observe할 때마다 이전 이벤트가 중복으로 발생하는 것이다.\n\n예를 들어, 토스트를 띄우는 이벤트가 발생했을 때 화면 회전하는 경우를 생각해 보자.\n\n1. LiveData를 observe한다.\n2. LiveData 값이 변경되면 LiveData는 옵저버에게 데이터를 emit하여 토스트가 뜬다.\n3. 화면 회전한다.\n4. 화면 회전에 의해 라이프사이클이 돌면서 액티비티가 재생성되고 LiveData를 다시 observe한다.\n5. LiveData는 observe할 때 마지막 값을 emit하여 토스트가 다시 뜬다.\n\n### ❌ 해결 1: LiveData의 값 되돌리기 (1)\n\n이벤트 발생 후에 LiveData의 value를 변경하는 식으로 중복 이벤트를 방지할 수 있다.\n\n```kotlin\nfun showSignIn() { \n    _showSignInEvent.value = true\n    _showSignInEvent.value = false\n}\n```\n\n하지만 이벤트 발생 후 값을 변경해 주는 것은 번거롭기도 하고, 개발자의 실수로 처리를 하지 않는 경우가 발생하기도 쉽다. 또한 LiveData는 값이 변경되었을 때 모든 경우에 emit 하지 않는다. showSignInEvent 값이 true로 변경되어도 활성 상태의 옵저버가 없다면 변경되었다는 것을 누구에게도 알리지 않고 다시 false로 바뀌게 될 수 있다.\n\n### ❌ 해결 2: LiveData의 값 되돌리기 (2)\n\nshowSignInEvent 값을 false로 되돌리는 함수를 뷰모델에 추가하고, startActivity() 이후에 호출하는 방법도 있을 것이다. 하지만 이 방식도 개발자의 실수로 LiveData값을 되돌리지 않는 경우가 생길 수 있다. 게다가 한 화면에 여러 이벤트가 존재한다면 각 이벤트마다 함수를 만들어야한다. (보일러플레이트!)\n\n### ⭕️ 해결 3: Event Wrapper\n\n이를 해결하기 위해 많이 사용되는 방법은 Event Wrapper를 사용하는 것이다. 안드로이드 샘플에서도 사용하는 널리 쓰이는 방식으로, 값을 Event로 감싸 이벤트를 한 번만 handle 하도록 한다.\n\n```kotlin\n/**\n * Used as a wrapper for data that is exposed via a LiveData that represents an event.\n */\nopen class Event<out T>(private val content: T) {\n\n    var hasBeenHandled = false\n        private set // Allow external read but not write\n\n    /**\n     * Returns the content and prevents its use again.\n     */\n    fun getContentIfNotHandled(): T? {\n        return if (hasBeenHandled) {\n            null\n        } else {\n            hasBeenHandled = true\n            content\n        }\n    }\n\n    /**\n     * Returns the content, even if it's already been handled.\n     */\n    fun peekContent(): T = content\n}\n```\n\nshowSignInEvent는 이제 LiveData<Event<Unit>> 타입이 된다.\n\n```kotlin\nclass MyPageViewModel(\n    // ...\n) : ViewModel() {\n\n    private val _showSignInEvent = MutableLiveData<Event<Unit>>()\n    val showSignInEvent: LiveData<Event<Unit>> get() = _showSignInEvent\n\n\t\t// ...\n\n\t\tfun showSignIn() {\n        _showSignInEvent.value = Event(Unit)\n    }\n}\n```\n\n이벤트가 발생한 후에는 getContentIfNotHandled()가 null을 리턴하므로 아래 코드처럼 처리하면 startActivity()가 한번 실행되도록 할 수 있다.\n\n```kotlin\n// MyPageFragment\n\nvm.showSignInEvent.observe(viewLifecycleOwner) { event ->\n    event.getContentIfNotHandled()?.let {\n        startActivity(SignInActivity.getIntent(requireContext()))\n    }\n}\n```\n\n### 🚀 개선 1: SingleLiveData\n\n위에 Event Wrapper 코드에서 확인할 수 있듯이 타입을 모두 Event로 감싸고, 이벤트를 생성할 때마다 Event로 감싸서 처리하는 것은 매우 귀찮은 일이다. 이를 개선하기 위해 SingleLiveData 내부에서 이를 처리한다.\n\n```kotlin\nabstract class SingleLiveData<T> {\n\n    private val liveData = MutableLiveData<Event<T>>()\n\n    protected constructor()\n\n    protected constructor(value: T) {\n        liveData.value = Event(value)\n    }\n\n    protected open fun setValue(value: T) {\n        liveData.value = Event(value)\n    }\n\n    protected open fun postValue(value: T) {\n        liveData.postValue(Event(value))\n    }\n\n    fun getValue() = liveData.value?.peekContent()\n\n    fun observe(owner: LifecycleOwner, onResult: (T) -> Unit) {\n        liveData.observe(owner) { it.getContentIfNotHandled()?.let(onResult) }\n    }\n\n    fun observePeek(owner: LifecycleOwner, onResult: (T) -> Unit) {\n        liveData.observe(owner) { onResult(it.peekContent()) }\n    }\n}\n```\n\n```kotlin\nclass MutableSingleLiveData<T> : SingleLiveData<T> {\n\n    constructor() : super()\n\n    constructor(value: T) : super(value)\n\n    public override fun postValue(value: T) {\n        super.postValue(value)\n    }\n\n    public override fun setValue(value: T) {\n        super.setValue(value)\n    }\n}\n```\n\n이제 SingleLiveData를 LiveData와 유사하게 사용하면서 이벤트가 한 번만 처리되도록 할 수 있다!\n\n```kotlin\nclass MyPageViewModel(\n    // ...\n) : ViewModel() {\n\n    private val _showSignInEvent = MutableSingleLiveData<Unit>()\n    val showSignInEvent: SingleLiveData<Unit> get() = _showSignInEvent\n\n\t\t// ...\n\n\t\tfun showSignIn() {\n        _showSignInEvent.setValue(Unit)\n    }\n}\n```\n\n```kotlin\nvm.showSignInEvent.observe(viewLifecycleOwner) {\n    startActivity(SignInActivity.getIntent(requireContext()))\n}\n```\n\n### 🚀 개선 2: sealed interface 활용하기\n\n페스타고 앱의 마이페이지에서는 5개의 이벤트가 발생할 수 있다.\n\n1. 로그인 화면으로 이동 (ShowSignIn)\n2. 로그아웃 성공 (SignOutSuccess)\n3. 회원 탈퇴 성공 (DeleteAccountSuccess)\n4. 과거 예매 내역 보기 (ShowTicketHistory)\n5. 정말 탈퇴하시겠어요? 다이얼로그 띄우기 (ShowConfirmDelete)\n\n위에서 살펴본 SingleLiveData를 사용해 뷰모델에 각 이벤트를 선언하면 어떻게 될까? MyPageViewModel에 Mutable 값을 포함해서 10개 프로퍼티가 추가될 것이다. MyPageFragment에서는 5개의 이벤트를 모두 따로 observe 해야 한다.\n\n화면에서 발생할 수 있는 이벤트들을 sealed interface로 묶어보자. 이제 뷰모델에서 _event, event 두 개의 프로퍼티로 화면 내 모든 이벤트를 관리할 수 있다.\n\n```kotlin\nsealed interface MyPageEvent {\n    object ShowSignIn : MyPageEvent\n    object SignOutSuccess : MyPageEvent\n    object DeleteAccountSuccess : MyPageEvent\n    object ShowTicketHistory : MyPageEvent\n    object ShowConfirmDelete : MyPageEvent\n}\n```\n\n```kotlin\nclass MyPageViewModel(\n    // ...\n) : ViewModel() {\n\n    private val _event = MutableSingleLiveData<MyPageEvent>()\n    val event: SingleLiveData<MyPageEvent> = _event\n\n}\n```\n\n이 글의 맨 처음에 언급했던 예시를 다시 떠올려보자.\n\n- 뷰모델에서 로그인 여부를 확인해 로그인된 사용자가 아닌 경우 SignInActivity로 이동한다.\n- 사용자가 마이페이지에서 회원 탈퇴를 한 경우 첫 화면으로 이동해 앱의 첫 화면에서 재시작 하도록 한다.\n\n두 예시는 다음과 같이 처리할 수 있다.\n\n```kotlin\nclass MyPageViewModel(\n    // ...\n) : ViewModel() {\n\n    private val _event = MutableSingleLiveData<MyPageEvent>()\n    val event: SingleLiveData<MyPageEvent> = _event\n\n\t\tfun loadUserInfo() {\n        if (!authRepository.isSigned) {\n            _event.setValue(MyPageEvent.ShowSignIn)\n            // ...\n        }\n        viewModelScope.launch {\n            // 유저 정보 불러오기\n        }\n    }\n\n\t\tfun deleteAccount() {\n        viewModelScope.launch {\n            authRepository.deleteAccount()\n                .onSuccess {\n                    _event.setValue(MyPageEvent.DeleteAccountSuccess)\n                    // ...\n                }.onFailure {\n                    // ...\n                }\n        }\n    }\n}\n```\n\nMyPageFragment에서는 event 하나만 observe하고 event가 MyPageEvent 중 어느 것인지 분기하여 이벤트를 처리한다.\n\n```kotlin\n// MyPageFragment\n\nvm.event.observe(viewLifecycleOwner) { event ->\n    when (event) {\n        is MyPageEvent.ShowSignIn -> handleShowSignInEvent()\n        is MyPageEvent.SignOutSuccess -> handleSignOutSuccessEvent()\n        is MyPageEvent.DeleteAccountSuccess -> handleDeleteAccountSuccess()\n        is MyPageEvent.ShowTicketHistory -> handleShowTicketHistory()\n        is MyPageEvent.ShowConfirmDelete -> handleShowConfirmDelete()\n    }\n}\n\nprivate fun handleShowSignInEvent() {\n    startActivity(SignInActivity.getIntent(requireContext()))\n}\n\n// ...\n```\n\n이벤트에 어떤 값을 전달하는 경우도 있을 수 있다. 예를 들어 페스타고 앱의 축제 목록 화면에서 축제 하나를 선택하면 티켓 예매 화면으로 넘어간다. 이때 축제 ID가 필요하다. 이런 이벤트는 다음과 같이 class로 이벤트를 정의할 수 있다.\n\n```kotlin\nsealed interface FestivalListEvent {\n    class ShowTicketReserve(val festivalId: Long) : FestivalListEvent\n}\n```\n\n```kotlin\n// FestivalListViewModel\n\n_event.setValue(ShowTicketReserve(festivalId))\n```\n\n```kotlin\n// FestivalListFragment\n\nprivate fun handleEvent(event: FestivalListEvent) {\n    when (event) {\n        is FestivalListEvent.ShowTicketReserve -> {\n            startActivity(TicketReserveActivity.getIntent(requireContext(), event.festivalId))\n        }\n    }\n}\n```\n\n**sealed interface 사용했을 때 장점**\n\n- 각 이벤트가 모두 MyPageEvent를 상속하기에 MyPageEvent이라는 하나의 타입으로 관리할 수 있다.\n- 각 이벤트를 뷰모델에 모두 따로 선언하고, 액티비티에서 각 이벤트를 observe 할 필요가 없다.\n- MyPage에서 발생할 수 있는 이벤트를 한곳에서 확인할 수 있다는 장점도 있다. 일종의 명세 역할을 한다고 볼 수 있다.\n\n**sealed interface 사용했을 때 단점**\n\n- 일관성 있게 화면마다 Event sealed interface를 정의한다면 이벤트가 하나만 있어도 sealed interface를 따로 만들어야한다. 관점에 따라 보일러플레이트라고 생각할 수 있다.\n"},{"excerpt":"안녕하세요. 페스타고팀의 애쉬입니다. 🏹 페스타고 팀에서 Facade 객체를 활용해 외부 API 통신을 분리한 과정을 설명하고자 합니다. 문제 상황 Oauth2 기반 로그인 메서드에서, Oauth2 API 통신이 트랜잭션 범위 안에 속해있었습니다.  외부 API 통신은 비교적 시간이 오래 걸리는 메서드로, 이가 트랜잭션 범위 안에 포함되면 DB 커넥션을 …","fields":{"slug":"/facade-service/"},"frontmatter":{"date":"September 11, 2023","title":"Facade 객체를 활용해 트랜잭션에서 외부 API 통신 분리하기","tags":["Facade Pattern"]},"rawMarkdownBody":"\n안녕하세요. 페스타고팀의 애쉬입니다. 🏹\n\n페스타고 팀에서 Facade 객체를 활용해 외부 API 통신을 분리한 과정을 설명하고자 합니다.\n\n## 문제 상황\n\n\nOauth2 기반 로그인 메서드에서, Oauth2 API 통신이 트랜잭션 범위 안에 속해있었습니다.\n\n![](images/image.png)\n\n외부 API 통신은 비교적 시간이 오래 걸리는 메서드로, 이가 트랜잭션 범위 안에 포함되면 DB 커넥션을 가지고 있는 시간과 트랜잭션이 활성화된 시간이 불필요하게 길어집니다. 이는 성능 저하와 직결되는 문제입니다.\n\n따라서 외부 API 통신 코드를 트랜잭션 범위에서 분리하는 것이 바람직합니다.\n\n## Facade 패턴 적용\n\n파사드 패턴(Facade Pattern)을 적용하여 해당 문제를 해결하였습니다.\n\n파사드 패턴이란, 서브 시스템을 감추는 상위 수준의 인터페이스를 제공함으로써 시스템의 복잡도를 낮추는 디자인 패턴입니.\n\n우리 팀은 아래와 같이 AuthService 상위에 AuthFacadeService 객체를 도입함으로써, 트랜잭션의 범위를 최소한으로 줄였습니다.\n\n(외부 API 통신과 함께, accessToken 생성 로직도 트랜잭션 범위에서 제외하였습니다.)\n\n![](images/image-1.png)\n\n아래는 파사드 객체를 도입한 코드입니다.\n\n```java\n@Service\npublic class AuthFacadeService {\n\n    private final AuthService authService;\n    private final OAuth2Clients oAuth2Clients;\n    private final AuthProvider authProvider;\n\n    /***/\n\n    public LoginResponse login(LoginRequest request) {\n        LoginMemberDto loginMember = authService.login(getUserInfo(request));\n        String accessToken = getAccessToken(loginMember.memberId());\n        return LoginResponse.of(accessToken, loginMember);\n    }\n\n    private String getAccessToken(Long memberId) {\n        return authProvider.provide(new AuthPayload(memberId, Role.MEMBER));\n    }\n\n    private UserInfo getUserInfo(LoginRequest request) {\n        OAuth2Client oAuth2Client = oAuth2Clients.getClient(request.socialType());\n        return oAuth2Client.getUserInfo(request.accessToken());\n    }\n\n    public void deleteMember(Long memberId) {\n        authService.deleteMember(memberId);\n    }\n}\n```\n\n```java\n@Service\n@Transactional\npublic class AuthService {\n\n    private final MemberRepository memberRepository;\n\n    /***/\n\n    public LoginMemberDto login(UserInfo userInfo) {\n        return memberRepository.findBySocialIdAndSocialType(userInfo.socialId(), userInfo.socialType())\n            .map(LoginMemberDto::isExists)\n            .orElseGet(() -> {\n                Member member = signUp(userInfo);\n                return LoginMemberDto.isNew(member);\n            });\n    }\n\n    private Member signUp(UserInfo userInfo) {\n        return memberRepository.save(userInfo.toMember());\n    }\n\n    public void deleteMember(Long memberId) {\n        Member member = memberRepository.findById(memberId)\n            .orElseThrow(() -> new NotFoundException(ErrorCode.MEMBER_NOT_FOUND));\n        memberRepository.delete(member);\n    }\n}\n```\n\n\n## 해당 PR 링크\n\nhttps://github.com/woowacourse-teams/2023-festa-go/pulls?q=is%3Apr+is%3Aclosed"},{"excerpt":"안녕하세요. 페스타고의 애쉬 입니다. 🏹 ‘대학 축제 줄서기 서비스’ 페스타고를 개발하며, 티켓팅 상황에서 동시성 보장을 위해 Redis를 도입해보았습니다. 아래는 저희 팀의 요구사항과 문제 상황, 그리고 해당 문제 상황의 해결책으로 Redis를 도입한 이유입니다. 1. 요구사항 티켓은 지정된 수량만큼만 발급되어야합니다. 2. 문제 상황 동시에 여러 사용…","fields":{"slug":"/concurrency-redis/"},"frontmatter":{"date":"September 10, 2023","title":"선착순 티켓팅에 Redis 도입하기","tags":["Redis"]},"rawMarkdownBody":"\n안녕하세요. 페스타고의 애쉬 입니다. 🏹\n\n‘대학 축제 줄서기 서비스’ 페스타고를 개발하며, 티켓팅 상황에서 동시성 보장을 위해 Redis를 도입해보았습니다.\n\n\n아래는 저희 팀의 요구사항과 문제 상황, 그리고 해당 문제 상황의 해결책으로 Redis를 도입한 이유입니다.\n\n\n## 1. 요구사항\n\n티켓은 지정된 수량만큼만 발급되어야합니다.\n\n## 2. 문제 상황\n\n동시에 여러 사용자가 예매할 때, 지정된 수량보다 더 많은 수량의 티켓이 예매됩니다.\n\n![](images/문제상황.png)\n\n## 3. 지금까지의 해결책\n\n티켓 수량의 정합성을 보장하기 위하여, **비관적 락**을 적용했습니다.\n\n하지만 비관적 락은 락을 얻기 위한 대기시간이 발생하기 때문에 성능적으로 좋지 않습니다.\n\n### 3-1. 성능 개선책\n\n#### ✅ TicketAmount 테이블 분리\n![](images/ticket도메인구조.png)\n\nTicket 테이블에서 수량 정보를 TicketAmount 테이블로 분리한 후, 해당 테이블에만 비관적 락을 적용함으로써 **락 범위를 최소화**했습니다.\n\n![](images/lock범위.png)\n\n\n#### ✅ N+1 쿼리 제거\n![](images/n+1.png)\nFetch Join을 활용해 N+1 쿼리를 제거했습니다.\n\n\n\n⇒ 결과적으로 **10% 정도의 성능 개선**을 이루어낼 수 있었습니다.\n\n\n## 4. 앞으로의 성능 개선책\n\n서버 단에서 성능 향상을 위해 일반적으로 캐싱과 DB 인덱스를 활용하곤 합니다.\n\n하지만 티켓 예매 로직에서 가장 큰 병목은 데이터의 조회가 아닌 **Lock을 얻기 위한 대기로 인해 발생**합니다.\n\n따라서, **가능한 Lock을 걸지 않는 것**이 성능을 향상 시키는 방법입니다.\n\n저희는 **DB의 티켓 수량을 변경**할 때, 정합성을 보장하기 위해서 Lock을 겁니다.\n\n따라서, **DB의 티켓 수량을 변경하지 않는 해결책**을 찾고자 했습니다.\n\n### 4-1. AtomicInteger의 활용\n\n첫번째 해결책으로 AtomicInteger를 활용해 **메모리에서 티켓의 수량을 변경하고 관리**하고자 했습니다.\n\n![](images/atomicInteger.png)\n\n이 방법은 DB의 데이터를 갱신하지 않기 때문에, 동시 예매 상황에서 발생하는 문제가 발생하지 않습니다.\n\n지금의 단일 서버에서는 문제가 발생하지 않지만, 무중단 배포를 위한 다중 서버 환경에서는 메모리 공유 문제가 발생합니다.\n\n티켓의 수량은 단순히 조회하는 값이 아닌 매 요청마다 변경되는 값이기 때문에 동기화에서 문제 발생이 우려됩니다.\n\n### 4-2. Redis 활용\n\nAtomicInteger의 대체제로 Redis를 활용했습니다.\n\nRedis는 싱글 스레드이며 multiplexing 기술을 활용하여 단일 프로세스가 모든 클라이언트 요청을 처리합니다. 따라서 모든 요청이 순차적으로 처리됩니다.\n\n네트워크 I/O가 존재하지만, 그럼에도 DB에 락을 거는 것 보다 성능이 훨씬 뛰어납니다.\n\n3000개의 요청을 처리하는데 DB 락을 활용한 방법은 평균 12800ms가 소요되는 반면, Redis를 활용한 방법은 평균 7500ms이 소요됩니다. 이는 **40% 이상의 성능 개선**입니다.\n\n| DB 락 | Redis |\n| --- | --- |\n| 12764 | 8249 |\n| 14217 | 7350 |\n| 12177 | 7123 |\n| 11969 | 7414 |\n\n## 5. Redis 활용법\n\n구체적인 Redis 활용법을 알아보도록 하겠습니다.\n\n![](images/티켓등록.png)\n\n\n### (1) 티켓 등록시 Redis에 값 넣어주기\n\n티켓을 등록하면, (`ticketAmount_ticketId`, `ticketAmount`) 데이터를 Redis에 등록합니다.\n(추가 수량 발급시, ticketAmount를 추가 수량만큼 더해줍니다.)\n\n\n```java\npublic void updateTicketAmount(TicketAmountChangeEvent ticketAmountChangeEvent) {\n    Long ticketId = ticketAmountChangeEvent.ticketId();\n    Integer ticketAmount = ticketAmountChangeEvent.ticketAmount();\n    redisTemplate.opsForValue().set(\"ticketAmount_\" + ticketId.toString(), ticketAmount.toString());\n}\n```\n\n### (2) 티켓팅시 Redis에서 수량 관리하기\n\n![](images/티켓팅.png)\n\n\nRedis의 DECR 연산으로티켓팅에서 해당 티켓의 잔여 수량을 조회함과 동시에, 잔여 수량을 1 감소합니다.\n\n이 때, 잔여 수량 \"조회\"와 \"1 감소\"는 원자적인 단위로 이루어져 동시성 문제가 발생하지 않습니다.\n\n\n```java\npublic Optional<Integer> getSequence(Ticket ticket) {\n    Integer totalAmount = ticket.getTicketAmount().getTotalAmount();\n    Long quantity = getQuantity(ticket.getId());\n    if (quantity == null || quantity < 0) {\n        return Optional.empty();\n    }\n    return Optional.of(totalAmount - quantity.intValue());\n}\n```\n\n잔여 수량이 0 이상이면, 티켓팅에 성공한 것으로 총 수량에서 잔여 수량을 빼 티켓 순번을 결정합니다.\n\n잔여 수량이 0보다 적으면 이는 품절된 것으로, 티켓팅에 실패합니다.\n\n\n\n\n## 6. 추가적인 활용법\n\n저희 서비스의 요구사항으로, 한 사용자는 특정 무대에 대해 한 장의 티켓만 발급할 수 있습니다.\n\n하지만 한 사용자가 동시에 여러 요청을 보내면, 티켓이 여러 장 발급되는 문제(일명 **“따닥” 문제**)가 발생했습니다.\n\n![](images/따닥.png)\n\n이는 DB의 MemberTicket 테이블에 **(memberId, stageId) Unique 제약조건**을 걸어줌으로써 해결할 수 있습니다.\n\n하지만 Unique 제약 조건은 Change Buffer 기능을 비활성화 시킴으로 데이터 삽입 연산의 성능이 저하되는 문제가 발생합니다.\n\n또한, 한 사용자당 발급 가능 횟수가 1회에서 2회로 변경될 경우 해당 방법으로 해결할 수 없습니다.\n\n이러한 따닥 문제를 해결하기 위한 해결책으로도 Redis를 활용하였습니다.\n\n\n### 6-1. 따닥 문제 해결하기\n\n티켓 예매 시도시, 해당 memberId와 stageId의 복합키 `trialCount_stageId_memberId` 의 값을 incrementAndGet 합니다.\n\n해당 연산의 반환값이, 발급 가능 매수보다 크면 예외처리합니다.\n\n해당 연산은 티켓 발급 가능 여부를 확인하는 연산과 **원자적인 단위**로 묶여있기 때문에, 동시 예매의 문제가 발생하지 않습니다.\n\n아래는 해당 연산의 스크립트입니다.\n\n```lua\nlocal memberTryCount = redis.call(\"INCR\", KEYS[1])\nredis.call(\"EXPIRE\", KEYS[1], 1)\n\n-- 따닥인 경우\nif memberTryCount > tonumber(ARGV[1])\nthen\n  return -2\nend\n\nlocal remainAmount = redis.call(\"DECR\", KEYS[2])\n\n-- 품절인 경우\nif remainAmount < 0\nthen\n  return -1\nend\n\nreturn remainAmount\n```\n\n아래는 lua 스크립트를 활용한 서비스 코드입니다.\n\n```java\npublic Optional<Integer> getSequence(Ticket ticket, Member member) {\n    Long remainAmount = redisTemplate.execute(\n        redisScript,\n        List.of(makeMemberKey(ticket, member), makeTicketAmountKey(ticket)),\n        MAX_MEMBER_TRIAL_COUNT);\n    if (remainAmount == null || remainAmount < 0) {\n        return Optional.empty();\n    }\n    Integer totalAmount = ticket.getTicketAmount().getTotalAmount();\n    return Optional.of(totalAmount - remainAmount.intValue());\n}\n\nprivate String makeMemberKey(Ticket ticket, Member member) {\n    Long stageId = ticket.getStage().getId();\n    Long memberId = member.getId();\n    return String.format(\"trialCount_%d_%d\", stageId, memberId);\n}\n\nprivate String makeTicketAmountKey(Ticket ticket) {\n    return String.format(\"ticketAmount_%d\", ticket.getId());\n}\n```\n\n\n---\n\n## **적용 코드 링크**\n\n[https://github.com/woowacourse-teams/2023-festa-go/pull/428](https://github.com/woowacourse-teams/2023-festa-go/pull/428)"},{"excerpt":"서론 안녕하세요. 페스타고의 글렌입니다. 🥃 페스타고에는 다양한 역할의 사용자가 존재합니다. 이렇게 다양한 역할의 사용자가 있다면 사용자의 역할에 맞는 인증과 인가 작업이 필요합니다. 단순히 역할에 따른 구분이라면 큰 문제가 없겠지만, 다양한 사용자들이 접속하는 환경에서 인증을 하는 방법에서 차이로 인해 문제가 발생했습니다. 어떠한 문제점에 직면했고, 이…","fields":{"slug":"/oauth2-multiple-user-auth/"},"frontmatter":{"date":"August 24, 2023","title":"페스타고의 인증 - 여러 사용자의 인증과 인가","tags":["OAuth2"]},"rawMarkdownBody":"\n## 서론\n\n안녕하세요.\n\n페스타고의 글렌입니다. 🥃\n\n페스타고에는 다양한 역할의 사용자가 존재합니다.\n\n이렇게 다양한 역할의 사용자가 있다면 사용자의 역할에 맞는 인증과 인가 작업이 필요합니다.\n\n단순히 역할에 따른 구분이라면 큰 문제가 없겠지만, 다양한 사용자들이 접속하는 환경에서 인증을 하는 방법에서 차이로 인해 문제가 발생했습니다.\n\n어떠한 문제점에 직면했고, 이것을 어떻게 해결했는지 설명하겠습니다.\n## 본론\n\n페스타고는 축제의 공연에 대한 티켓팅을 오프라인으로 기다리지 않고 온라인으로 편하게 예매하고 빠르게 출입을 가능하게 해주는 서비스입니다.\n\n잠깐 저희 서비스의 흐름에 관해 이야기를 해보겠습니다.\n\n사용자가 공연에 대해 티켓을 예매하려고 합니다.\n\n이때, 사용자가 티켓을 예매하려면 우선 공연과 축제가 생성되어 있어야 합니다.\n\n그렇다면 공연과 축제는 티켓을 예매하는 사용자가 생성을 하는 것일까요?\n\n공연과 축제를 생성하는 것은 티켓을 예매하는 사용자가 아닌, 축제와 공연을 개최하고 싶은 관리자입니다.\n\n그리고 예매한 티켓을 검사할 때도 마찬가지로, 티켓을 검사하는 사용자가 있습니다.\n\n티켓을 검사하는 사용자는 공연과 축제를 생성하는 관리자가 아닌, 관리자에 의해 고용된 스태프일 것입니다.\n\n이처럼 페스타고에는 역할별로 책임이 다른 사용자가 존재합니다.\n\n> 티켓을 예매하고 싶은 사용자 -> Member\n> \n> 축제와 공연을 계획하고 개최하고 싶은 사용자 -> Admin\n> \n> 티켓을 검사하고 싶은 사용자 -> Staff\n\n이렇듯 사용자들은 각자의 역할과 책임을 가지고 있습니다.\n\n그런데 어떻게 다양한 역할의 사용자를 구분할 수 있을까요?\n\n저희 서비스는 JWT 토큰을 기반으로 인증을 수행하니 JWT 토큰에 다음과 같은 값을 넣을 수 있을 것 같습니다.\n\n```json\n{\n    \"id\": 1,\n    \"role\": \"MEMBER\"\n}\n\n{\n    \"id\": 2,\n    \"role\": \"STAFF\"\n}\n\n{\n    \"id\": 3,\n    \"role\": \"ADMIN\"\n}\n```\n\n이렇게 토큰에 `role` 필드를 추가하면 사용자의 역할을 쉽게 구분할 수 있습니다.\n\n하지만 여기서 문제가 발생합니다.\n\n각 역할의 사용자들은 접속하는 환경이 다르다는 것입니다.\n\n일반 사용자와 스태프는 모바일 앱 환경에서 저희 서비스를 이용합니다.\n\n하지만 관리자는 모바일 앱을 사용하지 않고, 웹 페이지를 통해 저희 서비스를 이용합니다.\n\n관리자가 접속하는 환경에서는 전용 앱을 제작할 필요가 없고 간단한 웹 페이지만 있으면 되기 때문입니다.\n\n그런데 이것이 왜 문제가 되는 걸까요?\n\n모바일 앱 환경에서 요청을 보낼 때는 JWT 토큰을 HTTP 헤더에 담아 요청합니다.\n\n하지만 웹 페이지 환경에서는 JWT 토큰을 쿠키에 담아 요청합니다.\n\n이렇게 사용자의 환경마다 토큰을 보내는 방법이 다르니 문제가 발생합니다.\n\n여기서 이런 생각이 들 수 있습니다.\n\n> \"웹 페이지에서도 헤더에 토큰을 담아서 보내면 안되나요?\"\n\n웹 페이지를 통해 토큰을 헤더에 담아 요청을 하려면 다음과 같은 문제가 발생합니다.\n\n단순하게 토큰을 헤더에 담아 요청하는 과정은 다음과 같습니다.\n\n1. 로그인을 통해 token을 서버에서 얻는다.\n2. token을 어딘가에 저장한다.\n3. 요청마다 저장한 토큰을 헤더에 추가하여 서버에 전송한다.\n\n여기서 token을 어딘가에 저장해야 하는데, 저장할 장소는 `LocalStorage` 또는 `SessionStorage`를 사용합니다.\n\n그리고 다음과 같이 `Authorization` 헤더를 추가하여 요청을 보내면 됩니다.\n\n```js\nconst credentials = localStorage.getItem('credentials');\nfetch(\"/admin/function\", {  \n  method: \"POST\",  \n  headers: {  \n    \"Authorization\": `Bearer ${credentials}`,\n    \"Content-Type\": \"application/json\"  \n  },  \n  body: JSON.stringify(...)  \n})\n```\n\n코드만 본다면 저장된 토큰을 꺼내는 작업과 헤더에 토큰을 추가하는 작업 외에는 전혀 문제가 될 상황이라고 보이지는 않습니다.\n\n하지만 눈에 보이지 않는 보안 측면에 문제가 있습니다.\n\nLocalStorage 같은 저장소에 있는 값들은 XSS 공격에 취약하다는 것입니다.\n\n다음과 같은 자바스크립트 코드로 저희 서비스에서 제공된 토큰을 쉽게 탈취할 수 있습니다.\n\n```js\nlocalStorage.getItem('credentials');\n```\n\n하지만 쿠키 또한 자바스크립트 코드로 쉽게 XSS 공격이 가능합니다.\n\n다음과 같은 한 줄로 쿠키의 목록을 전부 출력할 수 있습니다.\n\n```js\ndocument.cookie;\n```\n\n하지만 쿠키의 경우 `HttpOnly`라는 플래그가 존재합니다.\n\n해당 플래그를 설정하면 자바스크립트로 접근할 수 없으므로, LocalStorage 보다 안전하게 토큰을 보관할 수 있습니다.\n\n또한 쿠키를 사용하면 매 요청 시 토큰을 꺼내고 헤더에 추가할 필요가 없으므로 개발의 편의성 또한 높습니다.\n\n따라서 이러한 상황으로 인해 헤더를 사용한 방법이 아닌, 쿠키를 사용한 방법을 선택했습니다.\n\n---\n### 기존의 인증 방식\n\n기존의 인증을 수행하는 방식은 다음과 같습니다.\n\n```java\n@Component\npublic class LoginMemberResolver implements HandlerMethodArgumentResolver {\n\n    private static final String BEARER_TOKEN_PREFIX = \"Bearer \";\n\n    private final AuthExtractor authExtractor;\n\n    public LoginMemberResolver(AuthExtractor authExtractor) {\n        this.authExtractor = authExtractor;\n    }\n\n    @Override\n    public boolean supportsParameter(MethodParameter parameter) {\n        return parameter.getParameterType().equals(LoginMember.class) && parameter.hasParameterAnnotation(Login.class);\n    }\n\n    @Override\n    public LoginMember resolveArgument(...) {\n        String header = webRequest.getHeader(HttpHeaders.AUTHORIZATION);\n        String token = extractToken(header);\n        AuthPayload authPayload = authExtractor.extract(token);\n        return new LoginMember(authPayload.getMemberId());\n    }\n\n    private String extractToken(String header) {\n        validateHeader(header);\n        return header.substring(BEARER_TOKEN_PREFIX.length()).trim();\n    }\n\n    private void validateHeader(String header) {\n        if (header == null) {\n            throw new UnauthorizedException(...);\n        }\n        if (!header.toLowerCase().startsWith(BEARER_TOKEN_PREFIX.toLowerCase())) {\n            throw new UnauthorizedException(...);\n        }\n    }\n}\n```\n\n이때는 역할이라는 도메인이 없고 단순히 사용자에 대한 인증만 있었기 때문에 `ArgumentResolver`로 인증 작업을 수행했습니다.\n\n따라서 다음과 같이 컨트롤러의 핸들러 메서드의 파라미터에 `@Login` 어노테이션을 붙이면 해당 핸들러에 인증 기능이 수행됩니다.\n\n```java\n@GetMapping(\"/profile\")\npublic ResponseEntity<MemberProfileResponse> findMemberProfile(@Login LoginMember loginMember) {\n    ...\n}\n```\n### 추가된 기능, 발생한 문제점\n\n지금까지 관리자 웹 페이지에 접속할 때 인증, 인가 작업 없이 누구나 접속이 가능했기 때문에 관리자에 대한 인증과 인가 기능을 추가해야 했습니다.\n\n위에서 설명했듯, 관리자에 대한 인증은 헤더가 아닌 쿠키를 사용합니다.\n\n하지만 기존의 인증 작업을 수행하는 `LoginMemberResolver`에는 헤더를 통한 인증만 되도록 구현되어 있습니다.\n\n```java\n@Component\npublic class LoginMemberResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override\n    public LoginMember resolveArgument(...) {\n        String header = webRequest.getHeader(HttpHeaders.AUTHORIZATION);\n        String token = extractToken(header);\n        AuthPayload authPayload = authExtractor.extract(token);\n        return new LoginMember(authPayload.getMemberId());\n    }\n    ...\n}\n```\n\n따라서 관리자의 인증은 기존의 `LoginMemberResolver`를 사용할 수 없고 새로운 `ArgumentResolver`가 필요합니다.\n\n```java\n@Component\npublic class LoginAdminResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override\n    public LoginMember resolveArgument(...) {\n        Cookie[] cookies = request.getCookies();\n        String token = extractToken(cookies);\n        AuthPayload authPayload = authExtractor.extract(token);\n        if (authPayload.getRole() != Role.ADMIN) {\n            throw new ForbiddenException(...);\n        }\n        return new LoginMember(authPayload.getId());\n    }\n}\n```\n\n그러면 이제 관리자 컨트롤러의 핸들러 메서드에는 다음과 같이 `@LoginAdmin` 어노테이션으로 관리자에 대한 인증과 인가를 수행할 수 있습니다.\n\n```java\n@PostMapping(\"/festivals\")\npublic ResponseEntity<Void> createFestival(@Admin LoginMember loginMember,\n                                           @RequestBody FestivalCreateRequest request) {\n    festivalService.create(request);  \n    return ResponseEntity.ok()\n        .build();\n}\n```\n\n이렇게 여러 사용자에 대한 인증과 인가 작업이 끝났을까요..?\n\n안타깝게도 여기에는 여러 문제점이 존재합니다.\n#### 필요하지 않은 파라미터\n\n`createFestival` 핸들러 메서드에서 `LoginMember` 파라미터를 사용하는 부분이 없습니다. 하지만 인증을 위해 핸들러 메서드의에 LoginMember 파라미터를 받아야 합니다.\n#### 정적 파일에 대한 인증\n\n인증 작업을 `ArgumentResolver`에서 수행하므로, 핸들러 메서드로 지정된 경로만 인증이 가능합니다.\n\n따라서 정적 파일에 대한 인증을 수행할 수 없습니다.\n\n따라서 관리자 웹 페이지의 JS 파일이 노출될 수 있습니다.\n\n> 어차피 JS 파일을 열어보더라도 인증이 되지 않으면 요청을 보낼 수 없긴 하나, 관리자의 엔드포인트가 노출된다는 점이 보안 측면에서 취약하다고 판단했습니다.\n### 어떻게 해결할 것인가?\n\n지금까지의 상황은 다음과 같습니다.\n\n![](images/20230822151035.png)\n![](images/20230822151040.png)\n![](images/20230822151045.png)\n\n따라서 문제점을 해결하려면, `ArgumentResolver`로 인증을 하는 것이 아닌 `Interceptor`로 특정 경로에 대한 인증을 수행하면 해결할 수 있습니다.\n\n> 여기서 `Interceptor`는  `HandlerInterceptor` 인터페이스를 구현한 클래스를 말합니다.\n\n`Interceptor`를 사용하면 요청과 응답을 공통으로 처리할 수 있습니다.\n\n또한 `HandlerInterceptor` 인터페이스에는 세 개의 default 메서드가 있습니다.\n\n```java\ndefault boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {  \n   return true;  \n}\n\ndefault void postHandle(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable ModelAndView modelAndView) throws Exception { \n}\n\ndefault void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, @Nullable Exception ex) throws Exception {  \n}\n```\n\n이 중에서 저희가 봐야할 메서드는 `preHandle()` 입니다.\n\n`preHandle()` 메서드는 요청이 들어올 때 실행되는 메서드로, 해당 메서드를 구현하여 요청이 핸들러 메서드로 넘어가기 전에 인증 과정을 처리할 수 있습니다.\n\n`HandlerInterceptor`를 구현한 Interceptor는 다음과 같이 `WebMvcConfigurer`를 구현한 클래스에 `addInterceptors()` 메서드를 재정의 한 뒤 `registry` 파라미터에 추가하면 됩니다.\n\n```java\n@Configuration\npublic class WebConfig implements WebMvcConfigurer {\n    ...\n    @Override  \n    public void addInterceptors(InterceptorRegistry registry) {  \n        registry.addInterceptor(adminAuthInterceptor())  \n            .addPathPatterns(\"/admin/**\", \"/js/admin/**\")  \n            .excludePathPatterns(\"/admin/login\");  \n        registry.addInterceptor(memberAuthInterceptor())\n            .addPathPatterns(\"/members/**\");\n    }\n\n    @Bean  \n    public HandlerInterceptor adminAuthInterceptor() {  \n        return new AuthInterceptor(Role.ADMIN, authExtractor);\n    }  \n      \n    @Bean  \n    public HandlerInterceptor memberAuthInterceptor() {  \n        return new AuthInterceptor(Role.MEMBER, authExtractor);\n    }\n}\n```\n#### Interceptor\n\n기존의 `ArgumentResolver`에서는 요청에서 토큰을 가져오는 것과 토큰을 `AuthExtractor`에 전달하여 `LoginMember`를 반환하는 두 가지의 책임이 있습니다.\n\n따라서 요청에서 토큰을 가져오는 책임을 Interceptor로 위임할 수 있을 것 같습니다.\n\n그런데 사용자와 관리자는 토큰을 보내는 방식이 달라서, 역할에 따라 토큰을 가져오는 메서드를 분리해야 합니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n\n    private final Role role;\n    private final AuthExtractor authExtractor;\n    \n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token;\n        if (role == Role.MEMBER) {\n            token = getHeaderToken(request);\n        }\n        if (role == Role.ADMIN) {\n            token = getCookieToken(request);\n        }\n        if (token == null) {\n            throw new UnauthorizedException(...);\n        }\n        AuthPayload authPayload = authExtractor.extract(token);\n        ...\n    }\n}\n```\n\n하지만 이 방법은 새로운 역할이 추가된다면 조건문이 추가로 생기게 될 것이고 한눈에 봐도 이 방법은 썩 유쾌하지 않아 보입니다.\n#### 서로 다른 인증 방식\n\n위의 구현에서는 요청에서 토큰을 가져오는 작업을 역할에 따라 구체적으로 처리하고 있습니다.\n\n역할에 따라 토큰을 가져오는 방식이 다른 것은 맞지만, 굳이 역할에 따라 토큰을 가져오는 방식을 분리할 필요가 있을까요?\n\n이것을 하나의 책임으로 본다면 다른 객체가 이것을 담당하게 하는 것을 생각해 볼 수 있습니다.\n\n```java\npublic interface TokenExtractor {\n    Optional<String> extract(HttpServletRequest request);\n}\n```\n\n그리고 `TokenExtractor`는 다음과 같이 두 개의 구현체로 구현됩니다.\n\n```java\npublic class CookieTokenExtractor implements TokenExtractor {\n    ...\n}\n\npublic class HeaderTokenExtractor implements TokenExtractor {\n    ...\n}\n```\n\n이제 요청에서 토큰을 가져오는 작업을 `TokenExtractor`에 위임할 수 있습니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n    ...\n    private final TokenExtractor tokenExtractor;\n\n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token = tokenExtractor.extract(request)\n            .orElseThrow(() -> new UnauthorizedException(...));\n        AuthPayload authPayload = authExtractor.extract(token);\n        if (authPayload.getRole() != role) {\n            throw new ForbiddenException(...);\n        }\n        return true; // boolean..?\n    }\n}\n```\n\n그런데 `preHandle()` 메서드의 반환 타입은 boolean인데, 어떻게 AuthPayload에 있는 값을 핸들러 메서드의 파라미터로 넘길 수 있을까요?\n#### HandlerInterceptor -> ArgumentResolver\n\n`preHandle()` 메서드로 넘어오는 `HttpServletRequest` 객체는 다음과 같은 메서드가 존재합니다.\n\n```java\nObject getAttribute(String name);\n\nvoid setAttribute(String name, Object o);\n```\n\n따라서 Interceptor에서 인증이 끝나고 반환된 `AuthPayload` 객체를 `setAttribute()` 메서드를 통해 `ArgumentResolver`로 전달할 수 있습니다.\n\n```java\npublic class AuthInterceptor implements HandlerInterceptor {\n\n    @Override  \n    public boolean preHandle(...) throws Exception {\n        String token = tokenExtractor.extract(request)\n            .orElseThrow(() -> new UnauthorizedException(...));\n        AuthPayload authPayload = authExtractor.extract(token);\n        request.setAttribute(AuthPayload.class.getName(), authPayload);\n        return true;\n    }\n}\n```\n\n이제 `ArgumentResolver`는 WebRequest 객체의  `getAttribute()` 메서드를 통해 `AuthPayload`를 꺼낸 뒤, 핸들러 메서드의 파리미터에 값을 매핑하면 됩니다.\n\n> Attribute의 key가 겹칠 수 있으므로, `AuthPayload.class.getName()`과 같이 해당 클래스의 고유한 패키지 명과 클래스 명을 사용하여 해당 문제를 해결하였습니다.\n\n```java\npublic class AuthArgumentResolver implements HandlerMethodArgumentResolver {\n    ...\n    @Override  \n    public LogimMember resolveArgument(...) throws Exception {  \n        AuthPayload authPayload = getAuthPayload(webRequest);\n        return new LoginMember(authPayload.getId()); \n    }\n\n    private AuthPayload getAuthPayload(NativeWebRequest request) {\n        AuthPayload authPayload = (AuthPayload) request.getAttribute(AuthPayload.class.getName(), RequestAttributes.SCOPE_REQUEST);  \n        if (authPayload == null) {  \n            return AuthPayload.ANONYMOUS; // new AuthPayload(null, Role.ANONYMOUS); \n        }  \n        return authPayload;\n    }\n}\n```\n\n따라서 이제부터 사용자가 접속하는 경로에 따라 인증과 인가 기능이 수행됩니다.\n![](images/20230822170744.png)\n### 인증 인가 테스트\n\n그렇다면 이제 모든 기능을 제작했으니 테스트 코드를 작성해야겠죠?\n\n관리자 페이지를 접속할 때, 관리자 권한이 아닌 사용자면 401 상태코드가 반환되는 것을 검증하는 테스트 코드를 작성해 보겠습니다.\n\n```java\n@WebMvcTest(AdminController.class)\nclass AdminControllerTest {\n    @Test\n    void 토큰의_Role이_어드민이_아니면_401() throws Exception {  \n        // when & then  \n        mockMvc.perform(get(\"/admin\")  \n                .cookie(new Cookie(\"token\", \"token\")))  \n            .andExpect(status().isUnauthorized());  \n    }\n}\n```\n\n해당 테스트 코드는 당연하게 실패합니다.\n\n왜냐하면 `Interceptor` 필드의 `AuthExtractor`가 빈으로 등록되어 있지 않기 때문입니다.\n\n또한 `AuthExtractor`는 인터페이스이고, 해당 테스트에서는 JWT 토큰으로 인증을 할 필요가 없습니다.\n\n따라서 Mockito의 `@MockBean` 어노테이션을 사용하거나, 테스트 클래스에서 `@Import` 어노테이션을 사용하여 `AuthExtractor`를 빈으로 등록하면 됩니다.\n\n```java\n@Import(FakeAuthExtractor.class) // Fake\n@WebMvcTest(AdminController.class)\nclass AdminControllerTest {\n\n    @MockBean\n    AuthExtractor authExtractor; // Mock\n}\n```\n\n그런데 이렇게 Fake 객체를 사용하거나, Mock 객체를 사용할 때 다음과 같은 문제가 발생합니다.\n#### Fake 사용의 문제\n\n`FakeAuthExtractor` 클래스는 다음과 같이 구현됩니다.\n\n```java\npublic class FakeAuthExtractor implements AuthExtractor {\n    @Override  \n    public AuthPayload extract(String token) {  \n        if (Objects.equals(token, \"member\")) {\n            return new AuthPayload(1L, Role.MEMBER);\n        }\n        if (Objects.equals(token, \"admin\")) {\n            return new AuthPayload(1L, Role.ADMIN);  \n        }\n        return AuthPayload.ANONYMOUS;\n    }\n}\n```\n\nJWT 토큰을 직접 파싱하여, AuthPayload 객체를 가져올 필요는 없으니 단순히 하드코딩된 값으로 AuthPayload 객체를 반환합니다.\n\n하지만 해당 Fake 객체의 문제점은 테스트 코드가 `FakeAuthExtractor`의 구현 사항에 의존적으로 변하게 됩니다.\n\n```java\nmockMvc.perform(get(\"/admin\")  \n        .cookie(new Cookie(\"token\", \"member\"))) // 새로운 역할이 생기면 FakeAuthExtractor를 수정해야 한다!\n    .andExpect(status().isUnauthorized());  \n```\n#### Mock 사용의 문제\n\nMockito를 사용하면 Stub 객체를 매우 쉽게 만들 수 있습니다.\n\n하지만 Stub이 필요한 메서드마다  `given()`과 같이 모의 동작을 정의해 줘야 하는 중복 코드가 발생합니다.\n\n```java\n@Test\nvoid test1() {  \n    // given\n    given(authExtractor.extract(anyString()))    \n        .willReturn(new AuthPayload(1L, Role.MEMBER));\n    ...\n}\n\n@Test\nvoid test2() {  \n    // given\n    given(authExtractor.extract(anyString()))    \n        .willReturn(new AuthPayload(1L, Role.ADMIN));\n    ...\n}\n```\n\n#### 공통적인 문제점\n\n결국 Fake 객체를 사용하던, Mock 객체를 사용하는 방법이든 간에 테스트가 정상적으로 동작하려면 `AuthExtrator` 빈이 필요합니다.\n\n따라서 컨트롤러의 테스트 코드마다 해당 객체를 빈으로 등록하는 코드를 매번 작성해야 합니다.\n\n```java\n@Import(FakeAuthExtractor.class) \n\n// 또는\n\n@MockBean\nAuthExtractor authExtractor;\n```\n\n이러한 문제점은  `@WebMvcTest` 테스트에서, MVC 관련 빈들만 불러오기 때문에 발생합니다.\n\n```java\n@TypeExcludeFilters(WebMvcTypeExcludeFilter.class) <--\n...\npublic @interface WebMvcTest {\n    ...\n}\n```\n\n`WebMvcTypeExcludeFilter` 클래스를 보면 다음과 같이 특정 빈들만 등록하는 것을 볼 수 있습니다.\n\n```java\npublic final class WebMvcTypeExcludeFilter extends StandardAnnotationCustomizableTypeExcludeFilter<WebMvcTest> {\n    ...\n    static {  \n       Set<Class<?>> includes = new LinkedHashSet<>();  \n       includes.add(ControllerAdvice.class);  \n       includes.add(JsonComponent.class);  \n       includes.add(WebMvcConfigurer.class);  \n       includes.add(WebMvcRegistrations.class);  \n       includes.add(jakarta.servlet.Filter.class);  \n       includes.add(FilterRegistrationBean.class);  \n       includes.add(DelegatingFilterProxyRegistrationBean.class); \n       includes.add(HandlerMethodArgumentResolver.class);  \n       includes.add(HttpMessageConverter.class);  \n       includes.add(ErrorAttributes.class);  \n       includes.add(Converter.class);  \n       includes.add(GenericConverter.class);  \n       includes.add(HandlerInterceptor.class);\n       ...\n   }\n}\n```\n\n그렇다면 해결법은 생각보다 단순합니다.\n\n`@WebMvcTest` 어노테이션을 확장한 커스텀 `@WebMvcTest` 어노테이션을 만들면 됩니다.\n\n```java\n@WebMvcTest  \n@Import(TestAuthConfig.class)  \n@Retention(RetentionPolicy.RUNTIME)  \npublic @interface CustomWebMvcTest {  \n  \n    @AliasFor(\"controllers\")  \n    Class<?>[] value() default {};  \n  \n    @AliasFor(\"value\")  \n    Class<?>[] controllers() default {};  \n}\n```\n\n`@WebMvcTest`에는 속성으로 테스트할 컨트롤러의 클래스를 적어줘야 합니다.\n\n만약 적어주지 않으면 모든 컨트롤러를 빈으로 주입하니, `NoSuchBeanDefinitionException` 예외가 발생하므로 특정 컨트롤러 클래스를 적어주기 위해 기존 `@WebMvcTest` 어노테이션에 있던 파라미터들을 적어주었습니다.\n\n그리고 `@Import` 어노테이션으로 `TestAuthConfig` 클래스를 빈으로 주입하였습니다.\n\n`TestAuthConfig` 클래스는 다음과 같습니다.\n\n```java\n@TestConfiguration  \npublic class TestAuthConfig {\n\n    @Bean\n    public AuthExtractor authExtractor() {\n        // return Mockito.mock(AuthExtractor.class);\n        return new FakeAuthExtractor();\n    }\n}\n```\n\n이제 `@CustomWebMvcTest` 어노테이션을 사용하면 중복된 코드를 적지 않아도 됩니다!\n\n```java\n@CustomWebMvcTest(AdminController.class)\nclass AdminControllerTest {\n    @Test\n    void 토큰의_Role이_어드민이_아니면_401() throws Exception {  \n        // when & then  \n        mockMvc.perform(get(\"/admin\")  \n                .cookie(new Cookie(\"token\", \"token\")))  \n            .andExpect(status().isUnauthorized());  \n    }\n}\n```\n### 여전한 문제점\n\n하지만 중복된 코드를 지우긴 했어도 여전히 근본적인 문제는 남아있습니다.\n\nFake를 사용할 것이냐, Mock을 사용할 것이냐입니다.\n\nFake를 사용한다면 테스트 코드가 Fake의 동작에 종속적으로 되고, Mock을 사용한다면 매번 모의 동작을 정의해야 하는 문제가 발생합니다.\n\n해당 테스트의 핵심은 인증 기능을 수행하는 것이 아닌, 인증이 된 사용자만 요청을 수행할 수 있는지 검증하는 것입니다.\n\n따라서 인증의 구체적인 방법은 중요하지 않고, 경로에 따라 쿠키를 사용하는지, 헤더를 사용하는지와 인가된 사용자를 구분만 하면 됩니다.\n\n그렇다면 어떻게 이런 작업을 중복된 코드 없이 간단하게 구현할 수 있을까요?\n#### TestExecutionListener\n\n스프링은 다음과 같은 인터페이스를 제공합니다.\n\n```java\npublic interface TestExecutionListener {\n    default void beforeTestClass(TestContext testContext) throws Exception {};\n    default void prepareTestInstance(TestContext testContext) throws Exception {};\n    default void beforeTestMethod(TestContext testContext) throws Exception {};\n    default void afterTestMethod(TestContext testContext) throws Exception {};\n    default void afterTestClass(TestContext testContext) throws Exception {};\n}\n```\n\n해당 인터페이스는 테스트를 실행할 때, 전처리 과정을 수행할 메서드를 정의할 수 있습니다.\n\n따라서 해당 인터페이스를 구현한 클래스를 테스트 클래스에 등록시키면 중복된 코드를 없앨 수 있습니다.\n\n다음과 같이 커스텀 어노테이션을 만들어, 인증이 필요한 테스트 메서드마다 적용을 한다면 좋을 것 같습니다.\n\n```java\n@Retention(RetentionPolicy.RUNTIME)  \n@Target(ElementType.METHOD)  \npublic @interface WithMockAuth {  \n  \n    long id() default 1;  \n  \n    Role role() default Role.MEMBER;  \n}\n```\n\n```java\n@Test\nvoid 사용자가_로그인을_하지_않으면_아니면_401() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().isUnauthorized());  \n}\n\n@Test\n@WithMockAuth(role = Role.MEMBER)\nvoid 사용자가_어드민이_아니면_401() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().isUnauthorized());  \n}\n\n@Test\n@WithMockAuth(role = Role.ADMIN)\nvoid 사용자가_어드민_이면_200() throws Exception {  \n    // when & then  \n    mockMvc.perform(get(\"/admin\")  \n            .cookie(new Cookie(\"token\", \"token\")))  \n        .andExpect(status().ikOk());  \n}\n```\n\n하지만 어떻게 구현을 해야할까요?\n#### TestExecutionListener 구현\n\n잠깐 `AuthInterceptor`의 `preHandle()` 메서드를 보겠습니다.\n\n```java\n@Override  \npublic boolean preHandle(...) throws Exception {\n    String token = tokenExtractor.extract(request)\n        .orElseThrow(() -> new UnauthorizedException(...));\n    AuthPayload authPayload = authExtractor.extract(token);\n    if (authPayload.getRole() != role) {\n        throw new ForbiddenException(...);\n    }\n    request.setAttribute(AuthPayload.class.getName(), authPayload);\n    return true;\n}\n```\n\n인증, 인가에 대한 가장 큰 핵심적인 부분은 `AuthExtractor` 클래스의 `extract()` 메서드 입니다.\n\n그렇다면 `TestExecutionListener`를 사용해서 테스트가 수행되기 전 전처리 작업을 통해서 `extract()` 메서드의 반환 값을 조작하면 될 것 같습니다.\n\n`TestExecutionListener`의 추상 메서드의 파라미터에는 공통으로 `TestContext` 객체가 제공됩니다.\n\n`TestContext` 객체에는 다음과 같은 메서드를 사용할 수 있습니다.\n\n```java\npublic interface TestContext extends AttributeAccessor, Serializable {\n    ...\n    Method getTestMethod();\n    ...\n    ApplicationContext getApplicationContext();\n    ...\n}\n```\n\n`getTestMethod()` 메서드로 제공되는 `Method` 객체에는 메소드에 특정 어노테이션이 붙어있는지 확인하고, 해당 어노테이션을 가져오는 메서드가 제공됩니다.\n\n```java\npublic boolean isAnnotationPresent(Class<? extends Annotation> annotationClass) {  \n    return super.isAnnotationPresent(annotationClass);  \n}\n\npublic <T extends Annotation> T getDeclaredAnnotation(Class<T> annotationClass) {  \n    return this.getAnnotation(annotationClass);  \n}\n```\n\n따라서 다음과 같이 테스트 메서드에 특정 어노테이션이 붙어있으면 다음과 같은 기능을 수행할 수 있습니다.\n\n1. 테스트 메서드에 특정 어노테이션이 붙어있는지 확인한다.\n2. 특정 어노테이션을 가져온다.\n3. ApplicationContext 객체를 가져온 뒤, AuthExtractor 빈을 꺼낸다.\n4. AuthExtractor가 특정 어노테이션의 속성으로 정의된 필드를 반환하도록 한다.\n\n테스트에 사용할 `AuthExtractor` 객체는 다음과 같이 구현하면 될 것 같습니다.\n\n```java\npublic class MockAuthExtractor implements AuthExtractor {  \n  \n    private Long memberId = null;  \n    private Role role = Role.ANONYMOUS;  \n  \n    public void setMemberId(Long memberId) {  \n        this.memberId = memberId;  \n    }  \n  \n    public void setRole(Role role) {  \n        this.role = role;  \n    }  \n  \n    @Override  \n    public AuthPayload extract(String token) {  \n        return new AuthPayload(memberId, role);  \n    }  \n}\n```\n\n그리고 `TestExecutionListener`를 구현한 클래스에서 `beforeTestMethod()` 메서드를 다음과 같이 구현할 수 있을 것 같습니다.\n\n또한 테스트가 끝나면 다른 테스트가 영향을 받지 않아야 하므로, `afterTestMethod()` 메서드도 다음과 같이 구현했습니다.\n\n```java\npublic class MockAuthTestExecutionListener implements TestExecutionListener {  \n  \n    @Override  \n    public void beforeTestMethod(TestContext testContext) throws Exception {  \n        Method testMethod = testContext.getTestMethod();  \n        if (testMethod.isAnnotationPresent(WithMockAuth.class)) {  \n            WithMockAuth withMockAuth = testMethod.getDeclaredAnnotation(WithMockAuth.class);  \n            ApplicationContext applicationContext = testContext.getApplicationContext();  \n            MockAuthExtractor authExtractor = applicationContext.getBean(MockAuthExtractor.class);  \n            authExtractor.setMemberId(withMockAuth.id());  \n            authExtractor.setRole(withMockAuth.role());  \n        }  \n    }\n\n    @Override  \n    public void afterTestMethod(TestContext testContext) throws Exception { \n        ApplicationContext applicationContext = testContext.getApplicationContext();  \n        MockAuthExtractor authExtractor = applicationContext.getBean(MockAuthExtractor.class);  \n        authExtractor.setMemberId(null);  \n        authExtractor.setRole(Role.ANONYMOUS);  \n    }\n}\n```\n\n그리고 이전에 만들었던 `@CustomWebMvcTest`에 `TestExecutionListener`를 사용하는 코드를 추가하면 모든 작업이 끝납니다.\n\n```java\n@WebMvcTest  \n@Import(TestAuthConfig.class)  \n@Retention(RetentionPolicy.RUNTIME)  \n@TestExecutionListeners(MockAuthTestExecutionListener.class) <--\npublic @interface CustomWebMvcTest {\n    ...\n}\n```\n\n하지만 테스트를 실행하면, 다음과 같은 예외가 발생하며 테스트가 실패합니다.\n\n```java\njava.lang.NullPointerException: Cannot invoke \"com.festago.application.StageService.create(com.festago.dto.StageCreateRequest)\" because \"this.stageService\" is null\n```\n\n왜냐하면 `@WebMvcTest`를 수행할 때, 기본적으로 등록된 `TestExecutionListener`가 있는데 `@TestExecutionListeners`를 새롭게 사용하면서 기존의 `TestExecutionListener`가 대체되었기 때문입니다.\n\n따라서 새로운 `TestExecutionListener`를 등록하면서 기존의 `TestExecutionListener`는 유지시켜야 합니다.\n\n이것은 `@TestExecutionListeners`의 `mergeMode` 속성으로 해결할 수 있습니다.\n\n```java\n@TestExecutionListeners(listeners = MockAuthTestExecutionListener.class, mergeMode = MergeMode.MERGE_WITH_DEFAULTS)\n```\n\n`@TestExecutionListeners`의 `mergeMode` 속성의 기본값은 `REPLACE_DEFAULTS` 입니다.\n\n따라서 `MERGE_WITH_DEFAULTS` 속성을 사용하여 기존의 `TestExecutionListener`를 대체하지 않고 새로운 `TestExecutionListener`를 추가할 수 있습니다.\n\n이제 인증, 인가가 필요한 테스트에 다음과 같은 어노테이션만 추가시키면 간편하게 인증, 인가 작업을 수행할 수 있습니다.\n\n```java\n@CustomWebMvcTest(AuthController.class)\nclass AuthControllerTest {\n    @Test\n    @WithMockAuth(role = Role.ADMIN)\n    void 멤버_권한이_아닌데_탈퇴하면_예외() throws Exception {\n        mockMvc.perform(delete(\"/auth\")\n                .header(\"Authorization\", \"Bearer token\")\n                .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isNotFound());\n    }\n\n    @Test\n    @WithMockAuth\n    void 회원_탈퇴를_한다() throws Exception {\n        mockMvc.perform(delete(\"/auth\")\n                .header(\"Authorization\", \"Bearer token\")\n                .contentType(MediaType.APPLICATION_JSON))\n            .andExpect(status().isOk());\n    }\n}\n```\n\n## 결론\n\n기존의 인증 방식에는 하나의 역할만 존재하여, 하나의 인증 방식만 사용하므로 단순한 방식의 인증 기능만 수행하면 됐습니다.\n\n하지만 관리자 또는 스태프같이 다양한 역할의 사용자가 추가되어 추가적인 인증 방식이 필요하게 됐습니다.\n\n따라서 새로운 인증 방식이 추가 되더라도 큰 변경 없이 인증 및 인가 작업이 필요하였고, 인증, 인가를 `Interceptor`에서 수행하도록 한 뒤, 토큰을 추출하고 토큰에서 인증 정보를 추출하는 책임을 가진 객체를 분리하여 재사용성이 높은 코드를 구현했습니다.\n\n또한 `@WebMvcTest` 테스트 코드에서 인증, 인가 작업으로 중복적으로 발생하게 되는 코드 또한 커스텀 어노테이션과 `TestExecutionListener`를 사용하여 중복된 코드를 해결할 수 있습니다.\n\n만약 `Request` 객체의 `Attribute`를 사용하고 싶지 않다면, `RequestScope` 범위를 가진 빈을 주입하여 해결할 수 있습니다.\n\n> `Attribute`에서 값을 꺼낼 때 Object 타입으로 추출이 되므로, 형변환 과정이 필요하고, 꺼낸 객체가 nullable 하므로 페스타고의 실제 코드에서는 `RequestScope` 범위의 빈을 사용하였습니다.\n"},{"excerpt":"서론 안녕하세요. 페스타고의 글렌입니다. 🥃 페스타고는 인증을 구현할 때, 최소한의 정보로 안전하게 인증을 구현할 수 있는 OAuth2를 채택하였습니다. OAuth2를 구현할 때 서비스를 제공하는 회사들은 매우 많습니다. 그중에서 저희가 선택한 OAuth2 제공자는  입니다. 카카오톡을 선택한 이유는 저희 서비스의 특성상 사용자 간의 티켓 거래를 막기 위…","fields":{"slug":"/oauth2-select-and-apply/"},"frontmatter":{"date":"August 20, 2023","title":"페스타고의 인증 - OAuth2를 선택하고 적용한 방법","tags":["OAuth2"]},"rawMarkdownBody":"\n## 서론\n\n안녕하세요.\n\n페스타고의 글렌입니다. 🥃\n\n페스타고는 인증을 구현할 때, 최소한의 정보로 안전하게 인증을 구현할 수 있는 OAuth2를 채택하였습니다.\n\nOAuth2를 구현할 때 서비스를 제공하는 회사들은 매우 많습니다.\n\n그중에서 저희가 선택한 OAuth2 제공자는 `카카오톡` 입니다.\n\n카카오톡을 선택한 이유는 저희 서비스의 특성상 사용자 간의 티켓 거래를 막기 위함인데요.\n\n구글이나 페이스북 등 쉽게 계정을 생성할 수 있는 서비스는 한 명의 사용자가 여러 계정을 통해 티켓을 예매할 수 있으므로, 국내에서 유일한 전화번호로 계정을 생성할 수 있는 서비스 제공자인 카카오톡을 선택하게 되었습니다.\n\n페스타고에서 구현한 OAuth2의 인증 플로우는 다음과 같습니다.\n\n![](images/20230819155223.png)\n\n이 방식은 `Authorization Code Grant Type`라고 불리는 OAuth2 인증 방식의 종류 중 하나입니다.\n\n해당 인증 방식은 사용자는 신뢰할 수 있는 OAuth2 인증 서버로 요청을 보내고, 인증 서버는 클라이언트(백엔드 스프링 서버)에 엑세스 토큰과 사용자 정보를 반환합니다.\n\n이러한 방식으로 사용자의 엑세스 토큰과 사용자 정보의 노출을 최소화할 수 있으므로 보안의 신뢰성이 높습니다.\n\n이러한 방식을 어떻게 코드로 구현하였는지 설명하겠습니다.\n\n코드로 구현할 클래스를 간략히 나타낸다면 한다면 다음과 같습니다.\n\n`SocialType`: Enum으로 OAuth2의 제공자를 나타냅니다. (ex: KAKAO)\n\n`AuthProvider`: 사용자 정보를 바탕으로 저희의 엑세스 토큰을 만들어 주는 역할을 합니다.\n\n`AuthExtractor`: 엑세스 토큰을 파싱하여 유효성을 검증하고 Payload의 값을 추출하는 역할을 합니다.\n\n`OAuth2Client`: OAuth2 인증, 리소스 서버로 요청을 보내고 엑세스 토큰, 사용자 정보 등 민감한 정보를 받는 역할을 합니다.\n\n`Member`: 사용자의 정보를 담고 있는 엔티티로, `SocialType`을 필드로 가지고 있습니다.\n\n`AuthService`: 인증을 수행하는 서비스 레이어 클래스입니다.\n\n여기서 `OAuth2Client`는 외부 API에 의존하므로, 인터페이스로 만들어 테스트나 로컬 환경에서 모의 객체를 만들 수 있도록 하였습니다.\n#### AuthProvider\n```java\npublic class JwtAuthProvider implements AuthProvider {  \n  \n    private static final int SECOND_FACTOR = 60;  \n    private static final int MILLISECOND_FACTOR = 1000;  \n    private static final String MEMBER_ID_KEY = \"memberId\";\n  \n    private final SecretKey key;  \n    private final long expirationMinutes;  \n  \n    public JwtAuthProvider(String secretKey, long expirationMinutes) {  \n        this.key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));  \n        this.expirationMinutes = expirationMinutes;  \n    }  \n  \n    @Override  \n    public String provide(AuthPayload authPayload) {  \n        Date now = new Date();  \n        return Jwts.builder()  \n            .claim(MEMBER_ID_KEY, authPayload.getMemberId())   \n            .setIssuedAt(now)  \n            .setExpiration(new Date(now.getTime() + expirationMinutes * SECOND_FACTOR * MILLISECOND_FACTOR))  \n            .signWith(key, SignatureAlgorithm.HS256)  \n            .compact();  \n    }  \n}\n```\n\nAuthProvider의 구현체인 `JwtAuthProvider` 입니다.\n\n`Member` 엔티티의 PK를 Payload에 넣어 JWT 토큰을 반환해 줍니다.\n\n해당 토큰은 앞으로 저희 서버에 인증 과정에 필요한 엑세스 토큰입니다.\n\n#### AuthExtractor\n```java\npublic class JwtAuthExtractor implements AuthExtractor {  \n  \n    private static final String MEMBER_ID_KEY = \"memberId\";  \n  \n    private final JwtParser jwtParser;  \n  \n    public JwtAuthExtractor(String secretKey) {  \n        SecretKey key = Keys.hmacShaKeyFor(secretKey.getBytes(StandardCharsets.UTF_8));  \n        this.jwtParser = Jwts.parserBuilder()  \n            .setSigningKey(key)  \n            .build();  \n    }  \n  \n    @Override  \n    public AuthPayload extract(String token) {  \n        Claims claims = getClaims(token);  \n        Long memberId = claims.get(MEMBER_ID_KEY, Long.class);  \n        return new AuthPayload(memberId);  \n    }  \n  \n    private Claims getClaims(String code) {  \n        try {  \n            return jwtParser.parseClaimsJws(code)  \n                .getBody();  \n        } catch (ExpiredJwtException e) {  \n            throw new UnauthorizedException(ErrorCode.EXPIRED_AUTH_TOKEN);  \n        } catch (JwtException | IllegalArgumentException e) {  \n            throw new UnauthorizedException(ErrorCode.INVALID_AUTH_TOKEN);  \n        }  \n    }  \n}\n```\n\nAuthExtractor의 구현체인 `JwtAuthExtractor` 입니다.\n\n토큰을 받아 `AuthPayload` 객체로 만들어 반환합니다.\n\n참고로 필드로 `JwtParser`를 가지고 있는데 이는 `Jwts.parserBuilder()` 메소드로 생성된 인스턴스는 불변하고, thread-safe 하기 때문입니다.\n\n![](images/20230818023037.png)\n\n따라서 다음과 같이 파싱할 때마다 인스턴스를 새롭게 만들지 않고, 기존의 인스턴스를 재사용할 수 있습니다.\n\n```java\n// 파싱마다 새로운 인스턴스 생성\nreturn Jwts.parserBuilder()  \n            .setSigningKey(key)  \n            .build()\n            .parseClaimsJws(code)  \n            .getBody();\n\n// 파싱마다 기존의 인스턴스 재사용\nreturn jwtParser.parseClaimsJws(code)  \n                .getBody();  \n```\n\n#### OAuth2Client\n```java\n@Component\npublic class KakaoOAuth2Client implements OAuth2Client {  \n  \n    private static final String ACCESS_TOKEN_URL = \"https://kauth.kakao.com/oauth/token\";  \n    private static final String USER_INFO_URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectId;  \n  \n    public KakaoOAuth2Client(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectId = redirectUri;  \n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.add(\"grant_type\", grantType);  \n        headers.add(\"client_id\", clientId);  \n        headers.add(\"redirect_uri\", redirectId);  \n        headers.add(\"code\", code);  \n  \n        try {  \n            KakaoAccessTokenResponse response = restTemplate.postForEntity(  \n                ACCESS_TOKEN_URL, headers,  \n                KakaoAccessTokenResponse.class).getBody();  \n            return response.accessToken();  \n        } catch (HttpClientErrorException e) {  \n            KakaoOAuth2Error kakaoOAuth2Error = e.getResponseBodyAs(KakaoOAuth2Error.class);  \n            if (kakaoOAuth2Error.isErrorCodeKOE320()) {  \n                throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n            }  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n  \n        try {  \n            KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                    KakaoUserInfo.class)  \n                .getBody();  \n            return UserInfo.ofKakao(kakaoUserInfo);  \n        } catch (HttpClientErrorException e) {  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }  \n  \n    public record KakaoOAuth2Error(  \n        String error,  \n        @JsonProperty(\"error_description\") String errorDescription,  \n        @JsonProperty(\"error_code\") String errorCode  \n    ) {  \n  \n        public boolean isErrorCodeKOE320() {  \n            return errorCode.equals(\"KOE320\");  \n        }  \n    }  \n}\n```\n\n실제 카카오 OAuth2 서비스 제공자에게 정보를 요청하는 `KakaoOAuth2Client` 입니다.\n\n코드에 지저분한 곳이 많고, 단일 책임 원칙을 지키지 않는 부분이 있습니다. (액세스 토큰 요청, 사용자 정보 요청)\n\n추후 이 부분을 어떻게 개선했는지 알려드리겠습니다.\n\n> record에 @JsonProperty를 사용한 이유는 [스택 오버플로우 링크](https://stackoverflow.com/questions/68394911/why-record-class-cant-be-properly-deserialized-with-jackson)에 나와 있습니다.\n\n#### AuthService\n```java\n@Service\n@Transactional\npublic class AuthService {  \n  \n    private final MemberRepository memberRepository;  \n    private final OAuth2Client oAuth2Client;  \n    private final AuthProvider authProvider;  \n  \n    public AuthService(MemberRepository memberRepository, OAuth2Client oAuth2Client, AuthProvider authProvider) {  \n        this.memberRepository = memberRepository;  \n        this.oAuth2Client = oAuth2Client;  \n        this.authProvider = authProvider;  \n    }  \n  \n    public LoginResponse login(String code) {  \n        String accessToken = oAuth2Client.getAccessToken(code);  \n        UserInfo userInfo = oAuth2Client.getUserInfo(accessToken);  \n        Member member = memberRepository.findBySocialIdAndSocialType(userInfo.socialId(), userInfo.socialType())  \n            .orElseGet(() -> memberRepository.save(userInfo.toMember()));  \n        return new LoginResponse(authProvider.provide(member), userInfo.nickname());  \n    }  \n}\n```\n\n컨트롤러에서 보내온 요청을 처리하는 서비스 클래스입니다.\n\n흐름은 맨 위에서 설명한 것과 같이 코드를 받아, OAuth2 서비스 제공자로부터 액세스 토큰을 얻고, 사용자 정보를 얻은 뒤 기존의 회원이 있으면 `AuthProvider`를 통해 액세스 토큰을 반환하고, 기존의 회원이 없다면 `orElseGet()` 메서드를 통해 회원을 생성하고 액세스 토큰을 반환합니다.\n\n---\n\n이렇게 구현한 방식에는 문제점이 있습니다.\n\n`OAuth2Client`의 코드를 보면 단일 책임 원칙을 지키지 못했고(액세스 코드와 사용자 정보를 모두 관리) 요청을 보낼 때 예외를 처리하기 위한 try-catch문 때문에 코드의 가독성이 나쁩니다.\n\n그리고 `OAuth2Client`를 인터페이스로 정의하여 변경에는 유연하게 대응했지만, 단일 인스턴스이기 때문에 다른 OAuth2 서비스 제공자가 추가될 경우 새로운 클래스 혹은 메소드가 필요합니다.\n\n### 단일 책임 원칙의 분리\n\n유명한 객체 지향 원칙인 SOLID 원칙에서 S는 단일 책임 원칙을 뜻합니다.\n\n스프링 프레임워크를 사용하며, 의존성 주입을 통한 OCP, DIP 원칙은 매우 쉽게 지킬 수 있으나, SRP 원칙은 구현하는 개발자가 객체가 가지는 책임을 얼마나 잘 구분할 수 있는지에 따라 달렸습니다.\n\nOAuth2Client는 두 가지 일을 처리합니다.\n1. 액세스 토큰을 요청\n2. 사용자 정보를 요청\n\n두 가지 일은 OAuth2 인증의 흐름으로는 하나의 작업으로 볼 수 있겠지만 객체가 가지는 책임은 두 가지 책임을 지고 있습니다.\n\n따라서, 엑세스 토큰만 요청하는 클래스와 사용자 정보만 요청하는 클래스로 나눠 설계할 수 있습니다.\n\n#### KakaoOAuth2AccessTokenClient\n```java\n@Component\npublic class KakaoOAuth2AccessTokenClient {  \n  \n    private static final String URL = \"https://kauth.kakao.com/oauth/token\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectUri;  \n  \n    public KakaoOAuth2AccessTokenClient(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,\n        @Value(\"${festago.oauth2.kakao.client-secret}\") String clientSecret,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectUri = redirectUri;  \n        this.clientSecret = clientSecret;\n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = getAccessTokenHeaders(code);  \n        return requestAccessToken(headers);  \n    }  \n  \n    private HttpHeaders getAccessTokenHeaders(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.set(\"grant_type\", grantType);  \n        headers.set(\"client_id\", clientId);  \n        headers.set(\"redirect_uri\", redirectUri);  \n        headers.set(\"client_secret\", clientSecret);\n        headers.set(\"code\", code);  \n        return headers;  \n    }  \n  \n    private String requestAccessToken(HttpHeaders headers) {  \n        try {  \n            KakaoAccessTokenResponse response = restTemplate.postForEntity(ACCESS_TOKEN_URL, headers,  \n                KakaoAccessTokenResponse.class).getBody();  \n            return response.accessToken();  \n        } catch (HttpClientErrorException e) {  \n            KakaoOAuth2Error kakaoOAuth2Error = e.getResponseBodyAs(KakaoOAuth2Error.class);  \n            if (kakaoOAuth2Error.isErrorCodeKOE320()) {  \n                throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n            }  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }  \n    }\n}\n```\n\n#### KakaoOAuth2UserInfoClient\n```java\n@Component\npublic class KakaoOAuth2UserInfoClient {  \n  \n    private static final String URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n  \n    public KakaoOAuth2UserInfoClient(RestTemplateBuilder restTemplateBuilder) {  \n        this.restTemplate = restTemplateBuilder.build();  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = getUserInfoHeaders(accessToken);  \n        return requestUserInfo(headers);  \n    }  \n  \n    private HttpHeaders getUserInfoHeaders(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n        return headers;  \n    }  \n  \n    private UserInfo requestUserInfo(HttpHeaders headers) {  \n        try {  \n            KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                    KakaoUserInfo.class)  \n                .getBody();  \n            return kakaoUserInfo.toUserInfo();  \n        } catch (HttpClientErrorException e) {  \n            throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR, e);  \n        }\n    }\n}\n```\n\n그리고 기존의 `KakaoOAuth2Client`는 다음과 같이 코드를 수정할 수 있습니다.\n\n```java\n@Component  \npublic class KakaoOAuth2Client implements OAuth2Client {\n\n    private final KakaoOAuth2AccessTokenClient accessTokenClient;  \n    private final KakaoOAuth2UserInfoClient userInfoClient;\n    \n    public KakaoOAuth2Client(KakaoOAuth2AccessTokenClient accessTokenClient, KakaoOAuth2UserInfoClient userInfoClient) {  \n        this.accessTokenClient = accessTokenClient;  \n        this.userInfoClient = userInfoClient;  \n    }\n\n    public String getAccessToken(String code) {  \n        return accessTokenClient.getAccessToken(code)\n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        return userInfoClient.getUserInfo(accessToken);\n    }  \n}\n```\n\n이제부터 `KakaoOAuth2Client` 클래스는 책임을 분리한 클래스에 요청을 위임하는 역할을 합니다.\n\n#### ResponseErrorHandler\n\n하지만 아직도 여전히 추한 try-catch가 코드에 남아있습니다.\n\n`RestTemplate` 클래스에서 발생한 예외를 처리하기 위해 어쩔 수 없이 try-catch문을 사용해야 합니다.\n\n그런데 여기서 잠깐,\n\n저희는 스프링을 사용하며 컨트롤러, 서비스 레이어에 try-catch를 잘 사용하지 않습니다.\n\n오히려 예외를 처리하지 않고 던져버립니다.\n\n그러는 이유는 요청의 예외를 전역적으로 처리해 주는 `@ControllerAdvice`를 사용하기 때문입니다.\n\n`RestTemplate` 클래스에서도 `@ControllerAdvice` 같은 역할을 할 수 있는 클래스가 있습니다.\n\n바로 `ResponseErrorHandler` 입니다.\n\n`ResponseErrorHandler`는 인터페이스로 다음과 같은 두 개의 추상 메소드를 가지고 있습니다.\n\n```java\npublic interface ResponseErrorHandler {\n\n    boolean hasError(ClientHttpResponse response) throws IOException;\n    \n    void handleError(ClientHttpResponse response) throws IOException;\n}\n```\n\n사실 이미 `RestTemplate`에서는 기본적인 `ResponseErrorHandler`가 등록되어 있습니다.\n\n```java\npublic class RestTemplate extends InterceptingHttpAccessor implements RestOperations {\n    ...\n    private ResponseErrorHandler errorHandler = new DefaultResponseErrorHandler();\n    ...\n}\n```\n\n따라서 기존의 `ResponseErrorHandler`를 사용하지 않고 커스텀한 에러 핸들러를 만들어 사용하면 예외 처리에 관한 로직을 분리할 수 있습니다.\n#### KakaoOAuth2AccessTokenErrorHandler\n```java\npublic class KakaoOAuth2AccessTokenErrorHandler extends DefaultResponseErrorHandler {  \n  \n    @Override  \n    public void handleError(ClientHttpResponse response) throws IOException {  \n        try {  \n            super.handleError(response);  \n        } catch (HttpStatusCodeException e) {  \n            HttpStatusCode statusCode = response.getStatusCode();  \n            handle4xxError(statusCode, e);  \n            handle5xxError(statusCode);  \n        }  \n        throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR);  \n    }  \n  \n    private void handle4xxError(HttpStatusCode statusCode, HttpStatusCodeException e) {  \n        if (statusCode.is4xxClientError()) {  \n            KakaoOAuth2ErrorResponse errorResponse = e.getResponseBodyAs(KakaoOAuth2ErrorResponse.class);  \n            handleErrorCode(errorResponse);  \n        }  \n    }  \n  \n    private void handleErrorCode(KakaoOAuth2ErrorResponse errorResponse) {  \n        handleKOE320Error(errorResponse);  \n        throw new InternalServerException(ErrorCode.OAUTH2_INVALID_REQUEST);  \n    }  \n  \n    private void handleKOE320Error(KakaoOAuth2ErrorResponse errorResponse) {  \n        if (errorResponse != null && errorResponse.isErrorCodeKOE320()) {  \n            throw new BadRequestException(ErrorCode.OAUTH2_INVALID_CODE);  \n        }  \n    }  \n  \n    private void handle5xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is5xxServerError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_PROVIDER_NOT_RESPONSE);  \n        }  \n    }  \n  \n    public record KakaoOAuth2ErrorResponse(  \n        String error,  \n        @JsonProperty(\"error_description\") String errorDescription,  \n        @JsonProperty(\"error_code\") String errorCode  \n    ) {  \n  \n        public boolean isErrorCodeKOE320() {  \n            return Objects.equals(errorCode, \"KOE320\");  \n        }  \n    }  \n}\n```\n\n#### KakaoOAuth2UserInfoErrorHandler\n```java\npublic class KakaoOAuth2UserInfoErrorHandler extends DefaultResponseErrorHandler {  \n  \n    @Override  \n    public void handleError(ClientHttpResponse response) throws IOException {  \n        HttpStatusCode statusCode = response.getStatusCode();  \n        handle4xxError(statusCode);  \n        handle5xxError(statusCode);  \n        throw new InternalServerException(ErrorCode.INTERNAL_SERVER_ERROR);  \n    }  \n  \n    private void handle4xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is4xxClientError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_INVALID_REQUEST);  \n        }  \n    }  \n  \n    private void handle5xxError(HttpStatusCode statusCode) {  \n        if (statusCode.is5xxServerError()) {  \n            throw new InternalServerException(ErrorCode.OAUTH2_PROVIDER_NOT_RESPONSE);  \n        }  \n    }  \n}\n```\n\n해당 에러 핸들러를 적용한 OAuth2Client는 다음과 같이 코드가 변경됩니다.\n#### KakaoOAuth2AccessTokenClient\n```java\n@Component\npublic class KakaoOAuth2AccessTokenClient {  \n  \n    private static final String URL = \"https://kauth.kakao.com/oauth/token\";  \n  \n    private final RestTemplate restTemplate;  \n    private final String grantType;  \n    private final String clientId;  \n    private final String redirectUri;  \n  \n    public KakaoOAuth2AccessTokenClient(  \n        @Value(\"${festago.oauth2.kakao.grant-type}\") String grantType,  \n        @Value(\"${festago.oauth2.kakao.client-id}\") String clientId,  \n        @Value(\"${festago.oauth2.kakao.redirect-uri}\") String redirectUri,\n        @Value(\"${festago.oauth2.kakao.client-secret}\") String clientSecret,  \n        RestTemplateBuilder restTemplateBuilder  \n    ) {  \n        this.grantType = grantType;  \n        this.clientId = clientId;  \n        this.redirectUri = redirectUri;  \n        this.clientSecret = clientSecret;\n        this.restTemplate = restTemplateBuilder\n            .errorHandler(new KakaoOAuth2AccessTokenErrorHandler())\n            .build();  \n    }  \n  \n    public String getAccessToken(String code) {  \n        HttpHeaders headers = getAccessTokenHeaders(code);  \n        return requestAccessToken(headers);  \n    }  \n  \n    private HttpHeaders getAccessTokenHeaders(String code) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.set(\"grant_type\", grantType);  \n        headers.set(\"client_id\", clientId);  \n        headers.set(\"redirect_uri\", redirectUri);  \n        headers.set(\"client_secret\", clientSecret);\n        headers.set(\"code\", code);  \n        return headers;  \n    }  \n  \n    private String requestAccessToken(HttpHeaders headers) {  \n        KakaoAccessTokenResponse response = restTemplate.postForEntity(ACCESS_TOKEN_URL, headers,  \n            KakaoAccessTokenResponse.class).getBody();  \n        return response.accessToken();  \n    }\n}\n```\n\n#### KakaoOAuth2UserInfoClient\n```java\n@Component\npublic class KakaoOAuth2UserInfoClient {  \n  \n    private static final String URL = \"https://kapi.kakao.com/v2/user/me\";  \n  \n    private final RestTemplate restTemplate;  \n  \n    public KakaoOAuth2UserInfoClient(RestTemplateBuilder restTemplateBuilder) {  \n        this.restTemplate = restTemplateBuilder\n            .errorHandler(new KakaoOAuth2UserInfoErrorHandler())\n            .build();  \n    }  \n  \n    public UserInfo getUserInfo(String accessToken) {  \n        HttpHeaders headers = getUserInfoHeaders(accessToken);  \n        return requestUserInfo(headers);  \n    }  \n  \n    private HttpHeaders getUserInfoHeaders(String accessToken) {  \n        HttpHeaders headers = new HttpHeaders();  \n        headers.setContentType(MediaType.APPLICATION_FORM_URLENCODED);  \n        headers.setBearerAuth(accessToken);  \n        return headers;  \n    }  \n  \n    private UserInfo requestUserInfo(HttpHeaders headers) {  \n        KakaoUserInfo kakaoUserInfo = restTemplate.postForEntity(USER_INFO_URL, new HttpEntity<>(headers),  \n                KakaoUserInfo.class)  \n            .getBody();  \n        return kakaoUserInfo.toUserInfo();  \n    }\n}\n```\n\n이처럼 예외를 처리하는 책임을 가진 객체로 분리하여, 요청을 보내는 객체에는 예외를 처리하는 코드 하나 없이 오로지 비즈니스 로직만 남게 된 것을 볼 수 있습니다.\n\n### 새로운 OAuth2 클라이언트의 추가\n\n서비스에서 사용하는 `OAuth2Client`는 인터페이스입니다.\n\n인터페이스로 설계하여, OAuth2 서비스 제공자가 바뀌더라도 쉽게 교체할 수 있고, 모의 OAuth2Client 객체를 만들어서 테스트할 때 외부 API의 연동 없이 테스트할 수 있습니다.\n\n하지만 이렇게 인터페이스를 사용하도록 만들어도, 인스턴스의 필드가 하나이기 때문에 추가적인 OAuth2Client를 사용하려면 서비스 제공자마다 서비스 클래스를 만들거나, 필드와 메소드가 생길 것입니다.\n\n```java\npublic class KakaoOAuth2Service{\n    ...\n};\n\npublic class NaverOAuth2Service{\n    ...\n};\n\n// 또는\n\npublic class AuthService {\n\n    private final OAuth2Client kakaoOAuth2Client;\n    private final OAuth2Client naverOAuth2Client;\n    \n    public void loginKakaoOAuth2(String code) {\n        ...\n    }\n    public void loginKakaoOAuth2(String code) {\n        ...\n    }\n}\n```\n\n이것은 단일 책임 원칙을 지켰다고 할 수 있겠지만, 중복된 코드가 생기게 되고 새로운 서비스 제공자가 생길 때 새로운 메소드를 추가해 줘야 합니다.\n\n그렇다면 어떻게 하나의 필드로 여러 `OAuth2Client`를 사용할 수 있을까요?\n\n스프링은 의존성을 주입할 때 컬렉션으로 의존성을 주입해 주는 기능을 제공합니다.\n\n따라서 다음과 같이 여러 `OAuth2Client`를 `List` 형식으로 받을 수 있습니다.\n\n```java\npublic class AuthService {\n\n    private final List<OAuth2Client> oAuth2Clients;\n\n    public AuthService(List<OAuth2Client> oAuth2Clients) {\n        this.oAuth2Clients = oAuth2Clients;\n    }\n}\n```\n\n이것이 바로 인터페이스를 의존하게 하면 얻을 수 있는 강력한 이점 중 하나입니다.\n\n그런데, 단순히 List 타입으로 받았다고 해서 끝나는 것은 아닙니다.\n\n리스트 중에서 사용자가 원하는 서비스 제공자를 선택할 수 있어야 합니다.\n\n```java\npublic OAuth2Client getClient(SocialType socialType) {\n    return oAuth2Clients.stream()\n        .filter(client -> client.getSocialType == socialType)\n        .findAny()\n        .orElseThrow(() -> BadRequestException(...));\n}\n```\n\n이렇게 Stream을 활용해서 사용자가 원하는 서비스 제공자를 선택할 수 있겠지만, 매번 Stream을 사용하여 원하는 서비스 제공자를 찾는 작업은 비효율적입니다.\n\n이때는 List 자료구조를 사용하는 것 보다 Map 자료구조를 사용하면 효율적일 것입니다.\n\n스프링은 Map 타입으로도 의존성 주입을 제공합니다.\n\n하지만 Map으로 의존성을 주입받으면 Key가 String인 `kakaoOAuth2Client`와 같이 지정됩니다.\n\n```java\nprivate final Map<String, OAuth2Client> oAuth2ClientMap;\n```\n\n따라서 다음과 같이 의존성 주입은 List로 받은 뒤, 내부에서 Map으로 변환시키면 Key가 Enum 타입인 Map을 사용할 수 있습니다.\n\n```java\nprivate final Map<SocialType, OAuth2Client> oAuth2ClientMap = new EnumMap<>(SocialType.class);\n\npublic AuthService(List<OAuth2Client> oAuth2Clients) {\n    for (OAuth2Client oAuth2Client: oAuth2Clients) {\n        oAuth2ClientMap.put(oAuth2Client.getSocialType(), oAuth2Client);\n    }\n}\n```\n\n이제 다음과 같이 특정 클라이언트를 빠르게 찾아올 수 있습니다.\n\n```java\npublic OAuth2Clients getOAuth2Client(SocialType socialType) {\n    return Optional.ofNullable(oAuth2ClientMap.get(socialType))  \n        .orElseThrow(() -> new BadRequestException(...));\n}\n```\n\n하지만 이것 또한 완벽하게 해결한 것은 아닙니다.\n\n필드에 `OAuth2Client`에 대한 자료구조가 그대로 노출이 되고 있습니다.\n\n`AuthService` 클래스에서 필요한 기능은 SocialType에 맞는 OAuth2Client만 선택하는 것입니다.\n\n`AuthService` 클래스는 Map에 대한 기능을 자세히 알 필요는 없습니다.\n\n이것은 저희가 레벨1부터 배워온 방법을 사용하면 쉽게 해결할 수 있습니다.\n\n바로 `일급 컬렉션`으로 만드는 것입니다.\n\n```java\n@Component\npublic class OAuth2Clients {\n    private final Map<SocialType, OAuth2Client> oAuth2ClientMap = new EnumMap<>(SocialType.class);\n\n    public OAuth2Clients(List<OAuth2Client> oAuth2Clients) {\n        for (OAuth2Client oAuth2Client: oAuth2Clients) {\n            oAuth2ClientMap.put(oAuth2Client.getSocialType(), oAuth2Client);\n        }\n    }\n\n    public OAuth2Client getClient(SocialType socialType) {\n        return Optional.ofNullable(oAuth2ClientMap.get(socialType))  \n            .orElseThrow(() -> new BadRequestException(...));\n    }\n}\n```\n\n그리고 `AuthService`의 코드는 다음과 같이 변합니다.\n\n```java\n@Service\n@Transactional\npublic class AuthService {\n    private final OAuth2Clients oAuth2Clients;\n\n    ...\n\n    public LoginResponse login(SocialType socialType, String code) {  \n        OAuth2Client oAuth2Client = oAuth2Clients.getClient(socialType);\n        String accessToken = oAuth2Client.getAccessToken(code);  \n        UserInfo userInfo = oAuth2Client.getUserInfo(accessToken);  \n        Member member = memberRepository.findBySocialIdAndSocialType(userInfo.socialId(), socialType)  \n            .orElseGet(() -> memberRepository.save(userInfo.toMember()));  \n        return new LoginResponse(authProvider.provide(member), userInfo.nickname());  \n    }  \n} \n```\n\n이제 새로운 OAuth2Client가 추가되어도 기존의 코드를 변경할 필요는 전혀 없어집니다.\n\n또한 로컬 환경 또는 테스트 환경을 위한 모의 OAuth2Client를 만들더라도 `@Profile`  어노테이션의 사용으로 운영 환경에서는 전혀 영향을 주지 않게 할 수 있습니다.\n\n```java\n@Component  \n@Profile(\"!prod\")  \npublic class FestagoOAuth2Client implements OAuth2Client {  \n  \n    private static final String PROFILE_IMAGE = \"https://placehold.co/150x150\";  \n  \n    private final Map<String, UserInfo> userInfoMap = new HashMap<>();  \n  \n    public FestagoOAuth2Client() {  \n        userInfoMap.put(\"1\", new UserInfo(\"1\", getSocialType(), \"member1\", PROFILE_IMAGE));  \n        userInfoMap.put(\"2\", new UserInfo(\"2\", getSocialType(), \"member2\", PROFILE_IMAGE));  \n        userInfoMap.put(\"3\", new UserInfo(\"3\", getSocialType(), \"member3\", PROFILE_IMAGE));  \n    }  \n  \n    @Override  \n    public UserInfo getUserInfo(String accessToken) {  \n        return Optional.ofNullable(userInfoMap.get(accessToken))\n            .orElseThrow(() -> new BadRequestException(...));\n    }  \n  \n    @Override  \n    public SocialType getSocialType() {  \n        return SocialType.FESTAGO;  \n    }  \n}\n```\n\n## 결론\n\nOAuth2를 사용한 인증 기능을 구현할 때, 스프링이 제공하는 의존성 주입 기능과 인터페이스를 사용한 다형성 활용 등, 객체 지향 설계를 따라 코드를 구현하면 변경에 유연하고 가독성이 높은 코드를 만들 수 있습니다.\n\n저희 서비스 특성상 새로운 OAuth2 서비스 제공자가 추가될 확률은 낮겠지만, 레벨 1, 2 과정을 배우며 습득한 객체 지향 설계 원칙을 이렇게 서비스에 녹여냈다는 점이 뿌듯한 것 같습니다.\n\n"}]}},"pageContext":{}},"staticQueryHashes":[],"slicesMap":{}}